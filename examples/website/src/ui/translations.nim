import
  ../../../../src/happyx


translatable:
  # ru - Russian
  # ja - Japanese
  # zh - Chinese
  # ko - Korean
  # fr - French
  "🌎 RoadMap":
    "ru" -> "🌎 Дорожная Карта"
    "ja" -> "🌎 ロードマップ"
    "zh" -> "🌎 路线图"
    "ko" -> "🌎 로드맵"
    "fr" -> "🌎 Map Feuille de route"
  "🔥 Sponsors":
    "ru" -> "🔥 Спонсоры"
    "ja" -> "🔥 スポンサー"
    "zh" -> "🔥 赞助人"
    "ko" -> "🔥 스폰서"
    "fr" -> "🔥 Sponsors"
  "📕 Documentation":
    "ru" -> "📕 Документация"
    "ja" -> "📕 書"
    "zh" -> "📕 文件"
    "ko" -> "📕 문서"
    "fr" -> "📕 Documentation"
  "Source code":
    "ru" -> "Исходный код"
    "ja" -> "ソースコード"
    "zh" -> "源代码"
    "ko" -> "소스 코드"
    "fr" -> "Code source"
  "Powerful macro-oriented full-stack web framework":
    "ru" -> "Мощный макроориентированный полнофункциональный веб-фреймворк"
    "ja" -> "強力なマクロ指向のフルスタックwebフレームワーク"
    "zh" -> "强大的面向宏的全栈web框架"
    "ko" -> "강력한 매크로 지향 풀 스택 웹 프레임 워크"
    "fr" -> "Puissant framework Web complet orienté macro"
  "modern and powerful ready-to-product web framework":
    "ru" -> "современный и мощный готовый к использованию веб-фреймворк"
    "ja" -> "現代および強力な準備ができてプロダクト網のフレームワーク"
    "zh" -> "现代而强大的现成产品web框架"
    "ko" -> "현대적이고 강력한 제품 준비가 된 웹 프레임 워크"
    "fr" -> "framework Web prêt à l'emploi moderne et puissant"
  "macro-oriented":
    "ru" -> "макро-ориентированный"
    "ja" -> "マクロ指向型"
    "zh" -> "宏导向"
    "fr" -> "orienté macro"
    "ko" -> "매크로 지향"
  "HappyX based on metaprogramming":
    "ru" -> "HappyX основан на метапрограммировании"
    "ja" -> "メタプログラミングに基づくHappyX"
    "zh" -> "基于元编程的HappyX"
    "ko" -> "메타프로그래밍 기반 해픽스"
    "fr" -> "HappyX basé sur la métaprogrammation"
  "so most part of code runs at compile-time.":
    "ru" -> "таким образом, большая часть кода выполняется во время компиляции."
    "ja" -> "したがって、コードのほとんどの部分はコンパイル時に実行されます。"
    "zh" -> "所以大部分代码在编译时运行。"
    "ko" -> "따라서 대부분의 코드는 컴파일 타임에 실행됩니다."
    "fr" -> "ainsi, la majeure partie du code s'exécute au moment de la compilation."
  "This means that HappyX is REALLY fastest web framework":
    "ru" -> "Значительно ускоряя ваш код во время выполнения"
    "ja" -> "これは、HappyXが本当に最速のwebフレームワークであることを意味します"
    "zh" -> "这意味着HappyX真的是最快的web框架"
    "ko" -> "이 해픽스는 정말 빠른 웹 프레임 워크를 의미합니다"
    "fr" -> "Cela signifie que HappyX est le framework Web le plus rapide"
  "full-stack":
    "ru" -> "полнофункциональный"
    "ja" -> "フルスタック"
    "zh" -> "全栈"
    "ko" -> "전체 스택"
    "fr" -> "pile complète"
  "HappyX is full-stack web framework":
    "ru" -> "HappyX - это полнофункциональный веб-фреймворк"
    "ja" -> "HappyXはフルスタックのwebフレームワークです"
    "zh" -> "HappyX是全栈web框架"
    "ko" -> "해픽스는 풀 스택 웹 프레임 워크입니다"
    "fr" -> "HappyX est un framework web complet"
  "so you shouldn't learn a new syntax/libraries/frameworks":
    "ru" -> "поэтому вам не следует изучать новый синтаксис / библиотеки / фреймворки"
    "ja" -> "したがって、新しい構文/ライブラリ/フレームワークを学ぶべきではありません"
    "zh" -> "所以你不需要学习新的语法/库/框架"
    "ko" -> "따라서 새로운 구문/라이브러리/프레임 워크를 배우면 안됩니다"
    "fr" -> "donc, vous ne devriez pas apprendre une nouvelle syntaxe / bibliothèques / frameworks"
  "to create modern and powerful web applications":
    "ru" -> "для создания современных и мощных веб-приложений"
    "ja" -> "最新かつ強力なwebアプリケーションを作成するには"
    "zh" -> "创建现代和强大的web应用程序"
    "ko" -> "현대적이고 강력한 웹 응용 프로그램을 만들려면"
    "fr" -> "pour créer des applications web modernes et puissantes"
  "ready-to-product":
    "ru" -> "готовый к внедрению"
    "ja" -> "すぐに使える製品"
    "zh" -> "现成产品"
    "ko" -> "제품 준비 완료"
    "fr" -> "prêt à l'emploi"
  "HappyX is ready-to-product web framework":
    "ru" -> "HappyX - это готовый к внедрению веб-фреймворк"
    "ja" -> "HappyXはすぐに製品のwebフレームワークです"
    "zh" -> "HappyX是现成的产品web框架"
    "ko" -> "해픽스는 제품 준비가 된 웹 프레임 워크입니다"
    "fr" -> "HappyX est un framework web prêt à l'emploi"
  "your company may use HappyX":
    "ru" -> "ваша компания может использовать HappyX"
    "ja" -> "あなたの会社はHappyXを使用することができます"
    "zh" -> "您的公司可能会使用HappyX"
    "ko" -> "회사는 해픽스를 사용할 수 있습니다"
    "fr" -> "votre entreprise peut utiliser HappyX"
  "SSR Example ⚡":
    "ru" -> "Пример SSR ⚡"
    "ja" -> "SSRの例 ⚡"
    "zh" -> "SSR示例 ⚡"
    "ko" -> "예를 들면 다음과 같습니다. ⚡"
    "fr" -> "Exemple de RSS ⚡"
  "SPA Example 🎴":
    "ru" -> "Пример SPA приложения 🎴"
    "ja" -> "スパの例¶ 🎴"
    "zh" -> "SPA的例子 🎴"
    "ko" -> "스파 예 🎴"
    "fr" -> "Exemple de SPA 🎴"
  "Server-side rendering application":
    "ru" -> "Серверное приложение для рендеринга"
    "ja" -> "サーバー側レンダリングアプリケーション"
    "zh" -> "服务器端渲染应用程序"
    "ko" -> "서버 측 렌더링 응용 프로그램"
    "fr" -> "Application de rendu côté serveur"
  "Single-page application":
    "ru" -> "Одностраничное приложение"
    "ja" -> "単一ページアプリケーション"
    "zh" -> "单页应用程序"
    "ko" -> "단일 페이지 응용 프로그램"
    "fr" -> "Demande d'une seule page"
  "FileResponse Example 📁":
    "ru" -> "Пример ответа на запрос файла 📁"
    "ja" -> "ファイル応答の例¶ 📁"
    "zh" -> "FileResponse示例 📁"
    "ko" -> "파일 응답 예제에는 다음과 같은 내용이 포함되어 있습니다.📁"
    "fr" -> "Exemple de Réponse de fichier 📁"
  "Respond file from server to client":
    "ru" -> "Файл ответа от сервера к клиенту"
    "ja" -> "サーバーからクライアントへのファイルの応答"
    "zh" -> "从服务器到客户端响应文件"
    "ko" -> "서버에서 클라이언트로 파일 응답"
    "fr" -> "Répondre le fichier du serveur au client"
  "Path Params In SSR ⚙":
    "ru" -> "Параметры пути в SSR ⚙"
    "ja" -> "SSRのパスパラメータ ⚙"
    "zh" -> "SSR中的路径参数 ⚙"
    "ko" -> "경로 파라미터를 사용하여 경로 파라미터를 사용하여 경로 파라미터를 만듭니다. ⚙"
    "fr" -> "Paramètres De Chemin Dans SSR ⚙"
  "PathParams in server-side rendering":
    "ru" -> "Параметры пути при рендеринге на стороне сервера"
    "ja" -> "サーバー側レンダリングでのPathParams"
    "zh" -> "服务器端渲染中的PathParams"
    "ko" -> "서버 측 렌더링의 경로 매개 변수"
    "fr" -> "Paramètres de chemin dans le rendu côté serveur"
  "Path Params In SPA ⚙":
    "ru" -> "Параметры пути в SPA приложении ⚙"
    "ja" -> "SPAのパスパラメータ¶"
    "zh" -> "Spa中的PathParams"
    "ko" -> "경로 Params 스파에서⚙"
    "fr" -> "Paramètres De Chemin À SPA ⚙"
  "PathParams in single-page application":
    "ru" -> "Параметры пути в одностраничном приложении"
    "ja" -> "シングルページアプリケーションのPathParams"
    "zh" -> "单页应用程序中的PathParams"
    "ko" -> "단일 페이지 응용 프로그램의 경로 매개 변수"
    "fr" -> "Paramètres de chemin dans une application d'une seule page"
  "Here is core features ✌.":
    "ru" -> "Вот основные возможности ✌."
    "ja" -> "以下は主要な機能です ✌."
    "zh" -> "以下是核心功能 ✌."
    "fr" -> "Voici les fonctionnalités principales ✌."
    "ko" -> "다음은 핵심 기능입니다 ✌."
  "Powerful DSLs":
    "ru" -> "Мощные DSL"
    "ja" -> "強力なDSL"
    "zh" -> "强大的DSL"
    "fr" -> "DSL puissants"
    "ko" -> "강력한 DSL"
  "Powerful routing":
    "ru" -> "Мощное маршрутизирование"
    "ja" -> "強力なルーティング"
    "zh" -> "强大的路由"
    "fr" -> "Routing puissant"
    "ko" -> "강력한 라우팅"
  "Make powerful full-stack apps with really same syntax ⚡":
    "ru" -> "Создавайте мощные полнофункциональные приложения с действительно одинаковым синтаксисом ⚡"
    "ja" -> "本当に同じ構文で強力なフルスタックアプリを作る ⚡"
    "zh" -> "用真正相同的语法制作强大的全栈应用程序 ⚡"
    "ko" -> "정말 동일한 구문으로 강력한 풀 스택 앱을 만드십시오.⚡"
    "fr" -> "Créez de puissantes applications full-stack avec la même syntaxe ⚡"
  "You can easily and effectively create powerful modern web apps ✌":
    "ru" -> "Вы можете легко и эффективно создавать мощные современные веб-приложения ✌"
    "ja" -> "あなたは簡単かつ効果的に強力な現代のwebアプリを作成することができます！✌"
    "zh" -> "您可以轻松有效地创建强大的现代web应用程序！✌"
    "ko" -> "강력한 최신 웹 앱을 쉽고 효과적으로 만들 수 있습니다."
    "fr" -> "Vous pouvez facilement et efficacement créer de puissantes applications Web modernes ✌"
  "You'll never have to learn new web frameworks again ✨":
    "ru" -> "Вам больше никогда не придется изучать новые веб-фреймворки ✨"
    "ja" -> "新しいwebフレームワークを再び学ぶ必要はありません！✨"
    "zh" -> "你再也不用学习新的web框架了！✨"
    "ko" -> "새로운 웹 프레임 워크를 다시 배울 필요가 없습니다.✨"
    "fr" -> "Vous n'aurez plus jamais à apprendre de nouveaux frameworks Web ✨"
  "HappyX goals is development speed ⚡, efficiency 🎴 and speed 🔥":
    "ru" -> "Цели HappyX - это скорость разработки ⚡, эффективность 🎴 и оперативность 🔥"
    "ja" -> "HappyXの目標は、開発スピード、効率、スピードです。"
    "zh" -> "HappyX的目标是发展速度、效率和速度。"
    "ko" -> "해픽스의 목표는 개발 속도,효율성,속도입니다."
    "fr" -> "Les objectifs d'HappyX sont la vitesse de développement⚡, l'efficacité 🎴 et la rapidité 🔥"
  "General features 🛠":
    "ru" -> "Общие характеристики 🛠"
    "ja" -> "一般的な機能 🛠"
    "zh" -> "一般特征 🛠"
    "ko" -> "일반적인 기능에는 다음이 포함됩니다. 🛠"
    "fr" -> "Caractéristiques générales 🛠"
  "SPA/SSR Support ⚡":
    "ru" -> "Поддержка SPA/SSR ⚡"
    "ja" -> "SPA/SSRサポート⚡"
    "zh" -> "SPA/SSR支持 ⚡"
    "ko" -> "지원 SPA/SSR ⚡"
    "fr" -> "Prise en charge SPA / SSR ⚡"
  "Multiple HTTP Servers 👨‍🔬":
    "ru" -> "Несколько HTTP-серверов 👨‍🔬"
    "ja" -> "複数のHTTPサーバ 👨‍🔬"
    "zh" -> "多个HTTP服务器 👨‍🔬"
    "ko" -> "여러 HTTP 서버 👨‍🔬"
    "fr" -> "Plusieurs serveurs HTTP 👨‍🔬"
  "Hot Code Reloading 🔥":
    "ru" -> "Горячая перезагрузка кода 🔥"
    "ja" -> "ホットコードリローディング 🔥"
    "zh" -> "热代码重新加载 🔥"
    "ko" -> "핫 코드를 다시 로드 🔥"
    "fr" -> "Rechargement de Code à chaud 🔥"
  "Framework improvement ⚡":
    "ru" -> "Улучшение структуры ⚡"
    "ja" -> "フレームワークの改善⚡"
    "zh" -> "框架改进⚡"
    "ko" -> "Framework 개선 ⚡"
    "fr" -> "Amélioration du cadre ⚡"
  "Additional HTTP Servers 👨‍🔬":
    "ru" -> "Дополнительные HTTP-серверы 👨‍🔬"
    "ja" -> "追加のHTTPサーバ 👨‍🔬"
    "zh" -> "其他HTTP服务器 👨‍🔬"
    "ko" -> "추가적인 HTTP 서버 👨‍🔬"
    "fr" -> "Serveurs HTTP supplémentaires 👨‍🔬"
  "Translatable Strings 🔥":
    "ru" -> "Переводимые строки 🔥"
    "ja" -> "翻訳可能な文字列 🔥"
    "zh" -> "可翻译字符串 🔥"
    "ko" -> "번역 가능한 문자열은 다음과 같습니다.🔥"
    "fr" -> "Cordes traduisibles 🔥"
  "Static Directories 📁":
    "ru" -> "Статические каталоги 📁"
    "ja" -> "静的ディレクトリ 📁"
    "zh" -> "静态目录 📁"
    "ko" -> "정 디렉토리 📁"
    "fr" -> "Répertoires Statiques 📁"
  "Components Update 🧩":
    "ru" -> "Обновление компонентов 🧩"
    "ja" -> "コンポーネント更新¶ 🧩"
    "zh" -> "组件更新 🧩"
    "ko" -> "구성 요소가 업데이트되는 이유는 무엇입니까? 🧩"
    "fr" -> "Mise à jour des composants 🧩"
  "Inheritance 👶":
    "ru" -> "Наследование 👶"
    "ja" -> "相続 👶"
    "zh" -> "继承 👶"
    "ko" -> "상속 👶"
    "fr" -> "L'héritage 👶"
  "Methods 📦":
    "ru" -> "Методы 📦"
    "ja" -> "法 📦"
    "zh" -> "方法 📦"
    "ko" -> "방법 📦"
    "fr" -> "Méthodes 📦"
  "Constructors ⚙":
    "ru" -> "Конструкторы ⚙"
    "ja" -> "コンストラクタ ⚙"
    "zh" -> "构造函数 ⚙"
    "ko" -> "생성자 ⚙"
    "fr" -> "Constructeurs ⚙"
  "Nim v2.0 Support ⚡":
    "ru" -> "Поддержка Nim версии 2.0 ⚡"
    "ja" -> "Nim v2.0のサポート¶ ⚡"
    "zh" -> "Nim v2.0支持！⚡"
    "ko" -> "Nim v2.0 지원 ⚡"
    "fr" -> "Prise en charge de Nim v2.0 ⚡"
  "Automatic Docs Generation 📕":
    "ru" -> "Автоматическое создание документов 📕"
    "ja" -> "ドキュメントの自動生成 📕"
    "zh" -> "自动生成文档 📕"
    "ko" -> "자동적인 문서를 생성 📕"
    "fr" -> "Génération Automatique de Documents 📕"
  ".hpx files support ✨":
    "ru" -> "поддержка файлов .hpx ✨"
    "ja" -> ".hpxファイルのサポート ✨"
    "zh" -> ".hpx文件支持 ✨"
    "ko" -> ".2018 년 10 월 15 일에 확인함. ✨"
    "fr" -> ".prise en charge des fichiers hpx ✨"
  "Python Bindings":
    "ru" -> "Привязки Python"
    "ja" -> "Pythonバインディング"
    "zh" -> "Python绑定"
    "ko" -> "파이썬 바인딩"
    "fr" -> "Liaisons Python"
  "Introduction ✌":
    "ru" -> "Введение ✌"
    "ja" -> "導入 ✌"
    "zh" -> "介绍 ✌"
    "ko" -> "소개이드 ✌"
    "fr" -> "Introduction ✌"
  "What Is HappyX? 💡":
    "ru" -> "Что такое HappyX? 💡"
    "ja" -> "HappyXとは何ですか 💡"
    "zh" -> "什么是HappyX 💡"
    "ko" -> "해픽스란? 💡"
    "fr" -> "Qu'Est-ce que HappyX? 💡"
  "🌐 Language":
    "ru" -> "🌐 Язык"
    "ja" -> "🌐 言語"
    "zh" -> "🌐 语言"
    "ko" -> "🌐 언어"
    "fr" -> "🌐 Langue"
  """
        is a macro-oriented full-stack web framework, written in Nim.
        This project has been under development since April 2023 and is continuously evolving.
        HappyX draws inspiration from notable web frameworks like Vue.js and FastAPI.
        """:
    "ru" -> """
        это макро-ориентированный полнофункциональный веб фреймворк, написанный на Nim.
        Этот проект развивается с апреля 2023-го года и продолжает улучшаться.
        HappyX вдохновлен такими веб фреймворками, как Vue.js и FastAPI.
        """
    "fr" -> """
        c'est un cadre web pleinement fonctionnel orienté macro, écrit en Nim.
        Ce projet est en développement depuis avril 2023 et continue de s'améliorer.
        HappyX est inspiré par des cadres web tels que Vue.js et FastAPI.
        """
    "ja" -> """
        これはNimで書かれたマクロ指向のフル機能ウェブフレームワークです。
        このプロジェクトは2023年4月から開発が進められており、ますます向上しています。
        HappyXはVue.jsやFastAPIのようなウェブフレームワークに触発されています。
        """
    "zh" -> """
        这是一个用Nim编写的宏导向的全功能Web框架。
        该项目从2023年4月开始开发，不断改进中。
        HappyX的设计灵感来源于诸如Vue.js和FastAPI之类的Web框架。
        """
    "ko" -> """
        이것은 Nim에서 작성된 매크로 지향적인 완전한 기능의 웹 프레임워크입니다.
        이 프로젝트는 2023년 4월부터 개발되어 계속 발전하고 있습니다.
        HappyX는 Vue.js와 FastAPI와 같은 웹 프레임워크에서 영감을 받았습니다.
        """
  "TIP":
    "ru" -> "Совет"
    "ja" -> "ヒント"
    "zh" -> "小费"
    "ko" -> "팁"
    "fr" -> "ASTUCE"
  "HappyX works with Nim, Python, JavaScript and TypeScript so you can choose one of these languages to read this guide ✌":
    "ru" -> "HappyX работает с Nim, Python, JavaScript и TypeScript, так что вы можете выбрать один из этих языков для прочтения данного руководства ✌"
    "ja" -> "HappyXはNim、Python、JavaScript、TypeScriptと連携しており、このガイドを読むためにこれらの言語の1つを選ぶことができます ✌"
    "zh" -> "HappyX与Nim、Python、JavaScript和TypeScript一起工作，因此您可以选择其中一种语言阅读本指南 ✌"
    "fr" -> "HappyX fonctionne avec Nim, Python, JavaScript et TypeScript, vous pouvez donc choisir l'une de ces langues pour lire ce guide ✌"
    "ko" -> "HappyX는 Nim, Python, JavaScript 및 TypeScript와 함께 작동하므로 이 안내서를 읽을 때 이 중 하나의 언어를 선택할 수 있습니다 ✌"
  "If you:":
    "ru" -> "Если вы:"
    "ja" -> "もしあなたが:"
    "zh" -> "如果你:"
    "ko" -> "만약 당신이:"
    "fr" -> "Si vous:"
  "are not keen on constantly \"switching\" your mindset from one language or web framework to another 🔥":
    "ru" -> "не стремитесь постоянно \"переключать\" свое мышление с одного языка или веб-фреймворка на другой 🔥"
    "ja" -> "ある言語やwebフレームワークから別の言語にあなたの考え方を常に\"切り替える\"ことに熱心ではありません！ 🔥"
    "zh" -> "不热衷于不断地 \"切换\" 你的思维方式从一种语言或web框架到另一种语言或web框架 🔥"
    "ko" -> "한 언어 또는 웹 프레임 워크에서 다른 언어 또는 웹 프레임 워크로의 사고 방식을 끊임없이\"전환\"하는 데 열중하지 않습니다. 🔥"
    "fr" -> "n'êtes pas désireux de\"changer\" constamment votre état d'esprit d'un langage ou d'un framework Web à un autre 🔥"
  "desire a lightweight web framework ⚡":
    "ru" -> "хотите легкий веб-фреймворк ⚡"
    "ja" -> "軽量なwebフレームワークを望む¶ ⚡"
    "zh" -> "渴望一个轻量级的web框架 ⚡"
    "ko" -> "가벼운 웹 프레임 워크를 원합니다. ⚡"
    "fr" -> "désirez un framework web léger ⚡"
  "seek a web framework with everything \"out of the box\" 📦":
    "ru" -> "ищите веб-фреймворк со всем \"из коробки\" 📦"
    "ja" -> "すべてのwebフレームワークを求める\"箱から出して\" 📦"
    "zh" -> "寻求一个web框架与一切\"开箱即用\" 📦"
    "ko" -> "모든 것을 가진 웹 프레임 워크를 찾으십시오\"상자 밖으로\" 📦."
    "fr" -> "cherchez un framework Web avec tout ce qui est \"prêt à l'emploi\" 📦"
  "Then, HappyX is the perfect fit for you. 😉":
    "ru" -> "Тогда HappyX идеально подходит для вас. 😉"
    "ja" -> "その後、HappyXはあなたにぴったりです。 😉"
    "zh" -> "那么，HappyX是最适合你的。 😉"
    "ko" -> "그런 다음,해픽스는 당신을위한 완벽한 적합합니다. 😉"
    "fr" -> "Alors, HappyX est la solution idéale pour vous. 😉"
  "Features 🔥":
    "ru" -> "Особенности 🔥"
    "ja" -> "特徴 🔥"
    "zh" -> "特点 🔥"
    "ko" -> "기능 🔥"
    "fr" -> "Caractéristiques 🔥"
  "Production-ready 🔌":
    "ru" -> "Готово к использованию 🔌"
    "ja" -> "本番運用対応 🔌"
    "zh" -> "生产就绪 🔌"
    "fr" -> "Prêt pour la production 🔌"
    "ko" -> "프로덕션 레디 🔌"
  "Multiple server options 🌩":
    "ru" -> "Несколько вариантов сервера 🌩"
    "ja" -> "複数のサーバーオプション¶ 🌩"
    "zh" -> "多个服务器选项 🌩"
    "ko" -> "여러 서버 옵션 중 하나를 선택할 수 있습니다. 🌩"
    "fr" -> "Plusieurs options de serveur 🌩"
  "Support Single-page applications, Static site generation and Server-side rendering 💫":
    "ru" -> "Поддержка одностраничных приложений, генерации статических сайтов и рендеринга на стороне сервера 💫"
    "ja" -> "シングルページアプリケーション、静的サイト生成、サーバー側レンダリングをサポート¶ 💫"
    "zh" -> "支持单页应用，静态站点生成和服务器端渲染！💫"
    "ko" -> "단일 페이지 응용 프로그램,정적 사이트 생성 및 서버 측 렌더링을 지원합니다. 💫"
    "fr" -> "Prise en charge des applications monopages, de la génération de sites statiques et du rendu côté serveur 💫"
  "Own Domain-specific languages for HTML, CSS and JavaScript 🎴":
    "ru" -> "Собственные предметно-ориентированные языки для HTML, CSS и JavaScript 🎴"
    "ja" -> "HTML、CSS、JavaScript用の独自のドメイン固有言語¶ 🎴"
    "zh" -> "拥有Html、CSS和JavaScript的特定领域语言 🎴"
    "ko" -> "자신의 도메인에 대해서는 특정 언어 HTML,CSS and JavaScript 🎴"
    "fr" -> "Propres langages spécifiques au domaine pour HTML, CSS et JavaScript 🎴"
  "Hot code reloading (only for Single-page applications for now) ⚡":
    "ru" -> "Горячая перезагрузка кода (пока только для одностраничных приложений) ⚡"
    "ja" -> "ホットコードリローディング（今のところ単一ページのアプリケーションのみ）⚡"
    "zh" -> "热代码重新加载（目前仅适用于单页应用程序）⚡"
    "ko" -> "핫 코드 다시로드(지금은 단일 페이지 응용 프로그램에만 해당). ⚡"
    "fr" -> "Rechargement de code à chaud (uniquement pour les applications d'une seule page pour l'instant) ⚡"
  "Routing/mounting with path param validation 👮‍♀️":
    "ru" -> "Маршрутизация/монтирование с проверкой параметров пути 👮"
    "ja" -> "パスパラメータ検証によるルーティング/マウント 👮"
    "zh" -> "路由/安装与path param验证 👮"
    "ko" -> "경로 매개 변수 유효성 검사를 사용하여 라우팅/마운팅하는 방법은 다음과 같습니다. 👮"
    "fr" -> "Routage / montage avec validation des paramètres de chemin ️ ️ 👮"
  "CLI for creating, serving and building your projects 💻":
    "ru" -> "CLI для создания, обслуживания и компоновки ваших проектов 💻"
    "ja" -> "プロジェクトを作成、提供、構築するためのCLI 💻"
    "zh" -> "创建、服务和构建项目用的CLI 💻"
    "ko" -> "귀하의 프로젝트를 만들고,제공하고,구축하기 위해 귀하의 프로젝트를 만들고,봉사하고,구축 할 수 있습니다. 💻"
    "fr" -> "CLI pour créer, servir et construire vos projets 💻"
  "Request models that supports JSON, FormData, x-www-form-urlencoded and XML 👮‍♀️":
    "ru" -> "Модели запросов, поддерживающие JSON, FormData, x-www-form-urlencoded и XML 👮"
    "ja" -> "JSON、FormData、x-www-form-urlencodedおよびXMLをサポートするリクエストモデル👮‍♀️"
    "zh" -> "支持JSON、FormData、x-www-form-urlencoded和XML的请求模型👮‍♀️"
    "ko" -> "이 응용 프로그램은 사용자 정의 모델,사용자 정의 모델,사용자 정의 모델,사용자 정의 모델 및 사용자 정의 모델을 지원합니다.👮‍♀️"
    "fr" -> "Modèles de requête prenant en charge JSON, FormData, x-www-form-urlencoded et XML ️ ️👮‍♀️ "
  "Translating, logging, security, built-in UI and more other features \"out of the box\" 📦":
    "ru" -> "Перевод, журналирование, безопасность, встроенный пользовательский интерфейс и множество других функций \"из коробки\" 📦"
    "ja" -> "翻訳、ロギング、セキュリティ、組み込みのUIとより多くの他の機能\"箱から出して\"📦"
    "zh" -> "翻译，日志记录，安全，内置UI和更多其他\"开箱即用\"的功能📦"
    "ko" -> "번역,로깅,보안,내장 된 사용자 인터페이스 및 기타 기타 기능\"상자 밖으로\"."
    "fr" -> "Traduction, journalisation, sécurité, interface utilisateur intégrée et plus d'autres fonctionnalité\"prêtes à l'emploi\""
  "Community 🌎":
    "ru" -> "Сообщество 🌎"
    "ja" -> "地域 🌎"
    "zh" -> "社区 🌎"
    "ko" -> "커뮤니티 🌎"
    "fr" -> "La communauté 🌎"
  "Maintainers":
    "ru" -> "Сопровождающие"
    "ja" -> "メンテナー"
    "zh" -> "维护者"
    "ko" -> "관리자"
    "fr" -> "Mainteneurs"
  "Contributors":
    "ru" -> "Участники"
    "ja" -> "コントリビューター"
    "zh" -> "贡献者"
    "ko" -> "기여자"
    "fr" -> "Contributeurs"
  "Getting Started 💫":
    "ru" -> "Приступая к работе 💫"
    "ja" -> "はじめに¶ 💫"
    "zh" -> "入门💫"
    "ko" -> "시작하기 💫"
    "fr" -> "Pour commencer 💫"
  "User Guide 📖":
    "ru" -> "Руководство пользователя 📖"
    "ja" -> "ユーザーガイド¶ 📖"
    "zh" -> "用户指南 📖"
    "ko" -> "사용자 안내 📖"
    "fr" -> "Guide de l'utilisateur 📖"
  "General 🍍":
    "ru" -> "Общие 🍍"
    "ja" -> "一般 🍍"
    "zh" -> "一般 🍍"
    "ko" -> "일반 🍍"
    "fr" -> "Général 🍍"
  "Basics 📖":
    "ru" -> "Основы 📖"
    "ja" -> "基礎 📖"
    "zh" -> "基本 📖"
    "ko" -> "기본 📖"
    "fr" -> "Notions de base 📖"
  "HappyX Application 🍍":
    "ru" -> "Приложение HappyX 🍍"
    "ja" -> "HappyX アプリケーション 🍍"
    "zh" -> "HappyX 应用程序 🍍"
    "fr" -> "Application HappyX 🍍"
    "ko" -> "HappyX 애플리케이션 🍍"
  "📕 API Reference":
    "ru" -> "📕 Справочник по API"
    "ja" -> "📕 APIリファレンス"
    "zh" -> "📕 API参考文档"
    "fr" -> "📕 Référence de l'API"
    "ko" -> "📕 API 참조"
  "Before you begin, please make sure you have":
    "ru" -> "Прежде чем начать, убедитесь, что у вас есть"
    "ja" -> "開始する前に、以下を確認してください"
    "zh" -> "开始之前，请确保您已经"
    "fr" -> "Avant de commencer, assurez-vous d'avoir"
    "ko" -> "시작하기 전에 다음 사항을 확인하세요"
  "Nim programming language":
    "ru" -> "Язык программирования Nim"
    "ja" -> "Nimプログラミング言語"
    "zh" -> "Nim编程语言"
    "ko" -> "닌 프로그래밍 언어"
    "fr" -> "Langage de programmation Nim"
  " version 1.6.14 or higher, or ":
    "ru" -> " версии 1.6.14 или выше, или "
    "ja" -> " バージョン1.6.14以上がインストールされているか、 "
    "zh" -> " 版本1.6.14或更高版本安装，或 "
    "ko" -> " 버전 1.6.14 이상 설치 또는 "
    "fr" -> " version 1.6.14 ou supérieure installée, ou "
  "Python programming language":
    "ru" -> "Язык программирования Python"
    "ja" -> "Pythonプログラミング言語"
    "zh" -> "Python编程语言"
    "ko" -> "파이썬 프로그래밍 언어"
    "fr" -> "Langage de programmation Python"
  " version 3.7 and above.":
    "ru" -> " версии 3.7 и выше."
    "ja" -> " バージョン3.7以上。"
    "zh" -> " 版本3.7及以上。"
    "ko" -> " 버전 3.7 이상."
    "fr" -> " version 3.7 et supérieure."
  " version 16.13.0 and above.":
    "ru" -> " версии 16.13.0 и выше."
    "ja" -> " バージョン16.13.0以上。"
    "zh" -> " 版本16.13.0及以上。"
    "fr" -> " version 16.13.0 et supérieure."
    "ko" -> " 버전 16.13.0 이상."
  "Installing 📥":
    "ru" -> "Установка 📥"
    "ja" -> "インストール中 📥"
    "zh" -> "正在安装 📥"
    "fr" -> "Installation en cours 📥"
    "ko" -> "설치 중 📥"
  "To install HappyX you can write this command":
    "ru" -> "Чтобы установить HappyX, вы можете написать эту команду"
    "ja" -> "HappyXをインストールするには、次のコマンドを書くことができます"
    "zh" -> "要安装HappyX，您可以编写此命令"
    "ko" -> "해픽스를 설치하려면이 명령을 쓸 수 있습니다"
    "fr" -> "Pour installer HappyX, vous pouvez écrire cette commande"
  "There is our first application. I show you ":
    "ru" -> "Вот наше первое приложение. Я покажу вам "
    "ja" -> "私たちの最初のアプリケーションがあります。 私はあなたを見せます "
    "zh" -> "这是我们的第一个应用程序。以 "
    "ko" -> "우리의 첫 번째 응용 프로그램이 있습니다. 내가 보여줘 "
    "fr" -> "Il y a notre première application. Je te montre "
  " example.":
    "ru" -> " пример."
    "ja" -> " 例を挙げてみます。"
    "zh" -> " 为例。"
    "ko" -> " 예."
    "fr" -> " exemple."
  "Run App ▶":
    "ru" -> "Запустите приложение ▶"
    "ja" -> "アプリの実行▶"
    "zh" -> "运行应用程序▶"
    "ko" -> "응용 프로그램을 실행하려면 응용 프로그램을 실행해야합니다▶"
    "fr" -> "Exécuter l'application ▶"
  "If you create Single-page application then you need ":
    "ru" -> "Если вы создаете одностраничное приложение, то вам нужно "
    "ja" -> "単一ページのアプリケーションを作成する場合は、次のものが必要です "
    "zh" -> "如果您创建单页应用程序，那么您需要 "
    "ko" -> "단일 페이지 응용 프로그램을 만드는 경우 다음이 필요합니다 "
    "fr" -> "Si vous créez une application d'une seule page, vous avez besoin de "
  "file:":
    "ru" -> "файл:"
    "ja" -> "ファイル:"
    "zh" -> "档案:"
    "ko" -> "파일:"
    "fr" -> "fichier:"
  "In this guide we create calculator app 🧮":
    "ru" -> "В этом руководстве мы создаем приложение-калькулятор 🧮"
    "ja" -> "このガイドでは、電卓アプリを作成します！ 🧮"
    "zh" -> "在本指南中，我们创建计算器应用程序！🧮"
    "ko" -> "이 가이드에서 우리는 계산기 응용 프로그램을 만들 수 있습니다. 🧮"
    "fr" -> "Dans ce guide, nous créons une application de calculatrice 🧮"
  "Create Application 📦":
    "ru" -> "Создать приложение 📦"
    "ja" -> "アプリケーションの作成 📦"
    "zh" -> "创建应用程序 📦"
    "ko" -> "응용 프로그램 만들기 응용 프로그램 만들기 응용 프로그램 만들기 📦"
    "fr" -> "Créer une Application 📦"
  "To create a new HappyX app you should use ":
    "ru" -> "Чтобы создать новое приложение HappyX, вы должны использовать "
    "ja" -> "新しいHappyXアプリを作成するには、次を使用する必要があります "
    "zh" -> "要创建一个新的HappyX应用程序，您应该使用 "
    "ko" -> "새로운 해픽스 앱을 만들려면 다음을 사용해야 합니다 "
    "fr" -> "Pour créer une nouvelle application HappyX, vous devez utiliser "
  " or follow project structure.":
    "ru" -> " или следуйте структуре проекта."
    "ja" -> " またはプロジェクト構造に従ってください。"
    "zh" -> " 或遵循项目结构。"
    "ko" -> " 또는 프로젝트 구조를 따르십시오."
    "fr" -> " ou suivez la structure du projet."
  "When you use CLI, HappyX do everything for you.":
    "ru" -> "Когда вы используете CLI, HappyX сделает все за вас."
    "ja" -> "あなたがCLIを使うとき、HappyXはあなたのためにすべてをします。"
    "zh" -> "当你使用CLI时，HappyX为你做一切。"
    "ko" -> "당신이 클리를 사용할 때,해픽스는 당신을 위해 모든 것을 할."
    "fr" -> "Lorsque vous utilisez CLI, HappyX fait tout pour vous."
  "Project Structure":
    "ru" -> "Структура проекта"
    "ja" -> "プロジェクト構造"
    "zh" -> "项目架构"
    "ko" -> "프로젝트 구조"
    "fr" -> "Structure du Projet"
  "Calculator Project 🧮":
    "ru" -> "Проект калькулятора 🧮"
    "ja" -> "電卓プロジェクト 🧮"
    "zh" -> "计算器项目 🧮"
    "ko" -> "프로젝트 계산기 🧮"
    "fr" -> "Projet de Calculatrice 🧮"
  "Import Library":
    "ru" -> "Импорт библиотеки"
    "ja" -> "ライブラリのインポート"
    "zh" -> "导入库"
    "ko" -> "라이브러리 가져오기"
    "fr" -> "Bibliothèque d'Importation"
  "To use ":
    "ru" -> "Использовать "
    "ja" -> "使用するには "
    "zh" -> "要使用 "
    "ko" -> "사용 방법 "
    "fr" -> "À utiliser "
  " on Nim we need to import it.":
    "ru" -> " в Nim нам нужно импортировать его."
    "ja" -> " Nimではインポートする必要があります。"
    "zh" -> " 在Nim上，我们需要导入它。"
    "ko" -> " 님에 우리는 그것을 가져올 필요가있다."
    "fr" -> " sur Nim, nous devons l'importer."
  "In this guide we need only ":
    "ru" -> "В этом руководстве нам нужно только "
    "ja" -> "このガイドでは、必要なのは "
    "zh" -> "在本指南中，我们只需要 "
    "ko" -> "이 가이드에서 우리는 필요 "
    "fr" -> "Dans ce guide, il suffit de "
  " function. So import it.":
    "ru" -> " функция. Так что импортируйте его."
    "ja" -> " 機能。 だからそれをインポートします。"
    "zh" -> " 函数。 所以导入它。"
    "ko" -> " 기능. 그래서 그것을 가져 오십시오."
    "fr" -> " fonction. Alors importez-le."
  "Next step is server declaration.":
    "ru" -> "Следующий шаг - объявление сервера."
    "ja" -> "次のステップはサーバー宣言です。"
    "zh" -> "下一步是服务器声明。"
    "ko" -> "다음 단계는 서버 선언입니다."
    "fr" -> "L'étape suivante est la déclaration du serveur."
  "Here we declare ":
    "ru" -> "Здесь мы заявляем "
    "ja" -> "ここで宣言します "
    "zh" -> "在这里我们声明 "
    "ko" -> "여기서 우리는 선언합니다 "
    "fr" -> "Ici, nous déclarons "
  " with ":
    "ru" -> " с "
    "ja" -> " と "
    "zh" -> " 与 "
    "ko" -> " 함께 "
    "fr" -> " avec "
  "IP-address":
    "ru" -> "IP-адрес"
    "ja" -> "IPアドレス"
    "zh" -> "IP地址"
    "ko" -> "주소"
    "fr" -> "Adresse IP"
  " and ":
    "ru" -> " и "
    "ja" -> " と "
    "zh" -> " 和 "
    "ko" -> " 그리고 "
    "fr" -> " et "
  "port":
    "ru" -> "порт"
    "ja" -> "港"
    "zh" -> "端口"
    "ko" -> "항구"
    "fr" -> "portuaire"
  "Next step is main app declaration.":
    "ru" -> "Следующий шаг - это объявление основного приложения."
    "ja" -> "次のステップはメインアプリ宣言です。"
    "zh" -> "下一步是主应用程序声明。"
    "ko" -> "다음 단계는 기본 앱 선언입니다."
    "fr" -> "L'étape suivante est la déclaration de l'application principale."
  "element ID":
    "ru" -> "идентификатор элемента"
    "ja" -> "要素ID"
    "zh" -> "元素ID"
    "ko" -> "요소 아이디"
    "fr" -> "ID d'ÉLÉMENT"
  " that will contain our app.":
    "ru" -> " который будет содержать наше приложение."
    "ja" -> " それには私たちのアプリが含まれます。"
    "zh" -> " 这将包含我们的应用程序。"
    "ko" -> " 그것은 우리의 앱을 포함 할 것입니다."
    "fr" -> " cela contiendra notre application."
  "Here we declare server with ":
    "ru" -> "Здесь мы объявляем сервер с "
    "ja" -> "ここでは、サーバーを宣言します "
    "zh" -> "在这里，我们声明服务器与 "
    "ko" -> "여기서 우리는 다음과 함께 서버를 선언합니다 "
    "fr" -> "Ici, nous déclarons le serveur avec "
  " route.":
    "ru" -> " маршрут."
    "ja" -> " ルート。"
    "zh" -> " 路由。"
    "ko" -> " 경로."
    "fr" -> " itinéraire."
  "Next we create ":
    "ru" -> "Далее мы создаем "
    "ja" -> "次に作成します "
    "zh" -> "接下来我们创建 "
    "ko" -> "다음으로 우리는 "
    "fr" -> "Ensuite, nous créons "
  "Here we declare route that contains three path params.":
    "ru" -> "Здесь мы объявляем маршрут, содержащий три параметра пути."
    "ja" -> "ここでは、3つのパスパラメータを含むルートを宣言します。"
    "zh" -> "这里我们声明包含三个路径参数的路由。"
    "ko" -> "여기서 우리는 세 개의 경로 매개 변수가 포함 된 경로를 선언합니다."
    "fr" -> "Ici, nous déclarons une route qui contient trois paramètres de chemin."
  "Server ✨":
    "ru" -> "Сервер ✨"
    "ja" -> "サーバー ✨"
    "zh" -> "服务器 ✨"
    "ko" -> "서버에 저희 유영배라는 이모부의 친구가 만 ✨"
    "fr" -> "Serveur ✨"
  "Web App ✨":
    "ru" -> "Веб-приложение ✨"
    "ja" -> "ウェブアプリ✨"
    "zh" -> "Web应用程序✨"
    "ko" -> "웹 앱은 저희 유영배라는 이모부의 친구가 만✨"
    "fr" -> "Application Web ✨"
  "Calculation 🧮":
    "ru" -> "Расчет 🧮"
    "ja" -> "計算 🧮"
    "zh" -> "计算 🧮"
    "ko" -> "계산 🧮"
    "fr" -> "Calcul 🧮"
  "Path Params 🔌":
    "ru" -> "Параметры пути 🔌"
    "ja" -> "パスパラメータ 🔌"
    "zh" -> "路径参数 🔌"
    "ko" -> "경로 매개 변수 🔌"
    "fr" -> "Paramètres du Chemin 🔌"
  "Routing 🛠":
    "ru" -> "Маршрутизация 🛠"
    "ja" -> "ルーティング 🛠"
    "zh" -> "路由 🛠"
    "ko" -> "라우팅 🛠"
    "fr" -> "Routage 🛠"
  "HappyX provides powerful routing system. Here contains these features:":
    "ru" -> "HappyX обеспечивает мощную систему маршрутизацию. В нее входят:"
    "ja" -> "HappyXは強力なルーティングシステムを提供します。 これらの機能が含まれている場所:"
    "zh" -> "HappyX提供强大的路由系统。 其中包含这些功能:"
    "ko" -> "해픽스는 강력한 라우팅 시스템을 제공합니다. 이 특징들이 포함된 곳:"
    "fr" -> "HappyX fournit un système de routage puissant. Où contient ces fonctionnalités:"
  "Path param validation (int/float/string/etc) 👮‍♀️":
    "ru" -> "Проверка параметров пути (int/float/string/etc) 👮‍♀️"
    "ja" -> "パスパラメータの検証(int/float/string/etc) 👮‍♀️"
    "zh" -> "路径参数验证（int/float/string/etc）️️ 👮‍♀️"
    "ko" -> "이 매개 변수 유효성 검사를 수행 할 수있는 방법은 다음과 같습니다. 👮‍♀️"
    "fr" -> "Validation du paramètre de chemin (int/float/string/etc) 👮‍♀️"
  "Automatic [im]mutable variable creation ✨":
    "ru" -> "Автоматическое создание (не)изменяемой переменной ✨"
    "ja" -> "(非)可変変数の自動作成 ✨"
    "zh" -> "自动创建（不）可变变量 ✨"
    "ko" -> "(비)가변 변수의 자동 생성 ✨"
    "fr" -> "Création automatique d'une variable (non)modifiable ✨"
  "Supports with any project type":
    "ru" -> "Поддерживается с любым типом проекта"
    "ja" -> "任意のプロジェクトタイプをサポート"
    "zh" -> "支持任何项目类型"
    "fr" -> "Prise en charge avec n'importe quel type de projet"
    "ko" -> "모든 프로젝트 유형과 호환"
  "Request models support 🛠":
    "ru" -> "Поддержка моделей запросов 🛠"
    "ja" -> "モデルのサポートを要求する 🛠"
    "zh" -> "请求模型支持 🛠"
    "ko" -> "모델 지원 요청 🛠"
    "fr" -> "Demander le support des modèles 🛠"
  "Custom types support 🔥":
    "ru" -> "Поддержка пользовательских типов 🔥"
    "ja" -> "カスタムタイプのサポート 🔥"
    "zh" -> "自定义类型支持 🔥"
    "fr" -> "Prise en charge des types personnalisés 🔥"
    "ko" -> "사용자 정의 타입 지원 🔥"
  "Route Param Types 📕":
    "ru" -> "Типы параметров маршрута 📕"
    "ja" -> "ルートパラメータタイプ 📕"
    "zh" -> "路由参数类型 📕"
    "ko" -> "경로 매개 변수 유형 📕"
    "fr" -> "Types de Paramètres de Route 📕"
  "Type":
    "ru" -> "Тип"
    "ja" -> "タイプ"
    "zh" -> "类型"
    "ko" -> "유형"
    "fr" -> "Type"
  "Usage":
    "ru" -> "Использование"
    "ja" -> "使用法"
    "zh" -> "使用方法"
    "ko" -> "사용"
    "fr" -> "Utilisation"
  "Usage alias":
    "ru" -> "Псевдоним использования"
    "ja" -> "使用方法エイリアス"
    "zh" -> "用法别名"
    "ko" -> "사용 별칭"
    "fr" -> "Alias d'utilisation"
  "Description":
    "ru" -> "Описание"
    "ja" -> "説明"
    "zh" -> "描述"
    "ko" -> "설명"
    "fr" -> "Description"
  "Parses param as integer value":
    "ru" -> "Принимает параметр как целочисленное значение"
    "ja" -> "パラメータを整数値として解析します"
    "zh" -> "将参数解析为整数值"
    "ko" -> "매개 변수를 정수 값으로 구문 분석"
    "fr" -> "Analyse le paramètre en tant que valeur entière"
  "Parses param as float value":
    "ru" -> "Принимает параметр как число с плавающей запятой"
    "ja" -> "パラメータをfloat値として解析します"
    "zh" -> "将参数解析为float值"
    "ko" -> "매개 변수를 플로트 값으로 구문 분석"
    "fr" -> "Analyse le paramètre en tant que valeur flottante"
  "Parses param as boolean value":
    "ru" -> "Разбирает параметр как логическое значение"
    "ja" -> "paramをブール値として解析します"
    "zh" -> "解析参数为布尔值"
    "fr" -> "Analyse le paramètre comme une valeur booléenne"
    "ko" -> "매개변수를 부울 값으로 구문 분석합니다"
  "Parses param as word (only \\w+)":
    "ru" -> "Разбирает параметр как слово (только \\w+)"
    "ja" -> "paramを単語として解析します（\\w+のみ）"
    "zh" -> "解析参数为单词（仅限 \\w+）"
    "fr" -> "Analyse le paramètre comme un mot (seulement \\w+)"
    "ko" -> "매개변수를 단어로 구문 분석합니다 (\\w+만)"
  "Parses param as string (any character exclude '/')":
    "ru" -> "Разбирает параметр как строку (любой символ, исключая '/')"
    "ja" -> "paramを文字列として解析します（'/'を除く任意の文字）"
    "zh" -> "解析参数为字符串（除'/'的任何字符）"
    "fr" -> "Analyse le paramètre comme une chaîne de caractères (tout caractère sauf '/')"
    "ko" -> "매개변수를 문자열로 구문 분석합니다 ('/'를 제외한 모든 문자)"
  "Parses param as string (any character include '/')":
    "ru" -> "Разбирает параметр как строку (любой символ, включая '/')"
    "ja" -> "paramを文字列として解析します（'/'を含む任意の文字）"
    "zh" -> "解析参数为字符串（包括'/'的任何字符）"
    "fr" -> "Analyse le paramètre comme une chaîne de caractères (tout caractère inclus '/')"
    "ko" -> "매개변수를 문자열로 구문 분석합니다 ('/'를 포함한 모든 문자)"
  "Parses param as Nim enum type (allow only for string enums)":
    "ru" -> "Разбирает параметр как перечисление типа Nim (разрешены только строковые перечисления)"
    "ja" -> "paramをNimの列挙型として解析します（文字列の列挙型のみ許可）"
    "zh" -> "解析参数为Nim枚举类型（仅允许字符串枚举）"
    "fr" -> "Analyse le paramètre comme un type énuméré Nim (autorise uniquement les énumérations de chaînes de caractères)"
    "ko" -> "매개변수를 Nim 열거형 타입으로 구문 분석합니다 (문자열 열거형만 허용)"
  "In addition, you can define your own parameter types ✌":
    "ru" -> "Кроме того, вы можете определить собственные типы параметров ✌"
    "ja" -> "さらに、独自のパラメータータイプを定義することができます ✌"
    "zh" -> "此外，您可以定义自己的参数类型 ✌"
    "fr" -> "De plus, vous pouvez définir vos propres types de paramètres ✌"
    "ko" -> "또한, 자체 매개변수 유형을 정의할 수 있습니다 ✌"
  "Assigning Route Params 🛠":
    "ru" -> "Назначение параметров маршрута 🛠"
    "ja" -> "ルートパラメーターの割り当て 🛠"
    "zh" -> "分配路由参数 🛠"
    "fr" -> "Attribution des paramètres de route 🛠"
    "ko" -> "경로 매개변수 할당 🛠"
  "At Nim side you can assign route params and use it anywhere":
    "ru" -> "В Nim вы можете назначить параметры маршрута и использовать их в любом месте"
    "ja" -> "Nim側では、ルートパラメーターを割り当て、どこでも使用できます"
    "zh" -> "在Nim一侧，您可以分配路由参数并在任何地方使用它"
    "fr" -> "Du côté Nim, vous pouvez attribuer des paramètres de route et les utiliser n'importe où"
    "ko" -> "Nim 측에서 경로 매개변수를 할당하고 어디에서나 사용할 수 있습니다"
  "Language binds":
    "ru" -> "Языковые привязки"
    "ja" -> "言語バインディング"
    "zh" -> "语言绑定"
    "fr" -> "Liens de langage"
    "ko" -> "언어 바인딩"
  "Single-page Applications 🎴":
    "ru" -> "Одностраничные приложения 🎴"
    "ja" -> "シングルページアプリケーション 🎴"
    "zh" -> "单页面应用 🎴"
    "fr" -> "Applications monopage 🎴"
    "ko" -> "싱글페이지 애플리케이션 🎴"
  "Server-side Applications 🖥":
    "ru" -> "Серверные приложения 🖥"
    "ja" -> "サーバーサイドアプリケーション 🖥"
    "zh" -> "服务器端应用程序 🖥"
    "fr" -> "Applications côté serveur 🖥"
    "ko" -> "서버 측 애플리케이션 🖥"
  "Single-page Applications Basics 🎴":
    "ru" -> "Основы одностраничных приложений 🎴"
    "ja" -> "シングルページアプリケーションの基礎 🎴"
    "zh" -> "单页面应用基础 🎴"
    "fr" -> "Fondamentaux des applications monopage 🎴"
    "ko" -> "싱글페이지 애플리케이션 기본 🎴"
  "Server-side Applications Basics 🖥":
    "ru" -> "Основы серверных приложений 🖥"
    "ja" -> "サーバーサイドアプリケーションの基礎 🖥"
    "zh" -> "服务器端应用程序基础 🖥"
    "fr" -> "Fondamentaux des applications côté serveur 🖥"
    "ko" -> "서버 측 애플리케이션 기본 🖥"
  "With HappyX you can easily create modern single-page applications.":
    "ru" -> "С HappyX вы легко можете создавать современные одностраничные приложения."
    "ja" -> "HappyXを使用すれば、簡単にモダンなシングルページアプリケーションを作成できます。"
    "zh" -> "使用 HappyX，您可以轻松创建现代单页面应用程序。"
    "fr" -> "Avec HappyX, vous pouvez facilement créer des applications monopage modernes."
    "ko" -> "HappyX를 사용하면 현대적인 싱글페이지 애플리케이션을 쉽게 만들 수 있습니다."
  "Features 📦":
    "ru" -> "Возможности📦"
    "ja" -> "機能 📦"
    "zh" -> "功能📦"
    "fr" -> "Fonctionnalités 📦"
    "ko" -> "기능 📦"
  "Here are the main features of single-page applications 👋":
    "ru" -> "Вот основные возможности одностраничных приложений 👋"
    "ja" -> "こちらがシングルページアプリケーションの主な機能です 👋"
    "zh" -> "以下是单页应用程序的主要功能 👋"
    "fr" -> "Voici les principales fonctionnalités des applications à page unique 👋"
    "ko" -> "여기 단일 페이지 애플리케이션의 주요 기능이 있습니다 👋"
  "Components":
    "ru" -> "Компоненты"
    "ja" -> "コンポーネント"
    "zh" -> "组件"
    "fr" -> "Composants"
    "ko" -> "구성 요소"
  "Components allow you to write HTML with some OOP features and use it anywhere":
    "ru" -> "Компоненты позволяют вам писать HTML с некоторыми объектно-ориентированными возможностями и использовать его где угодно"
    "ja" -> "コンポーネントを使用すると、いくつかのOOP機能を備えたHTMLを書いてどこでも使用できます"
    "zh" -> "组件允许您在HTML中添加一些面向对象编程的特性，并在任何地方使用它"
    "fr" -> "Les composants vous permettent d'écrire du HTML avec certaines fonctionnalités de programmation orientée objet et de l'utiliser n'importe où"
    "ko" -> "컴포넌트를 사용하면 일부 OOP 기능을 갖춘 HTML을 작성하고 어디에서나 사용할 수 있습니다"
  "Event handlers":
    "ru" -> "Обработчики событий"
    "ja" -> "イベントハンドラ"
    "zh" -> "事件处理程序"
    "fr" -> "Gestionnaires d'événements"
    "ko" -> "이벤트 핸들러"
  "Event handlers allow you to handle button clicks, input text, and more.":
    "ru" -> "Обработчики событий позволяют обрабатывать нажатия кнопок, ввод текста и многое другое."
    "ja" -> "イベントハンドラを使用すると、ボタンクリック、テキスト入力などを処理できます。"
    "zh" -> "事件处理程序允许您处理按钮点击、文本输入等等。"
    "fr" -> "Les gestionnaires d'événements vous permettent de gérer les clics de bouton, la saisie de texte, et plus encore."
    "ko" -> "이벤트 핸들러를 사용하면 버튼 클릭, 텍스트 입력 등을 처리할 수 있습니다."
  "Routes":
    "ru" -> "Маршруты"
    "ja" -> "ルート"
    "zh" -> "路由"
    "fr" -> "Routes"
    "ko" -> "경로"
  "Routes allow you to navigate between different pages.":
    "ru" -> "Маршруты позволяют перемещаться между разными страницами."
    "ja" -> "ルートを使用すると、異なるページ間を移動できます。"
    "zh" -> "路由允许您在不同页面之间进行导航。"
    "fr" -> "Les routes vous permettent de naviguer entre différentes pages."
    "ko" -> "경로를 통해 다른 페이지로 이동할 수 있습니다."
  "SPA means that all web-app logic runs at the client-side (e.g., browser).":
    "ru" -> "SPA означает, что вся логика веб-приложения выполняется на стороне клиента (например, в браузере)."
    "ja" -> "SPAは、ウェブアプリケーションのすべてのロジックがクライアントサイド（例：ブラウザ）で実行されることを意味します。"
    "zh" -> "SPA表示所有的Web应用程序逻辑运行在客户端（例如，浏览器）。"
    "fr" -> "SPA signifie que toute la logique de l'application web s'exécute côté client (par exemple, dans le navigateur)."
    "ko" -> "SPA는 모든 웹 애플리케이션 논리가 클라이언트 측(예: 브라우저)에서 실행된다는 것을 의미합니다."
  "Routing 🔌":
    "ru" -> "Маршрутизация 🔌"
    "ja" -> "ルーティング 🔌"
    "zh" -> "路由 🔌"
    "fr" -> "Routing 🔌"
    "ko" -> "라우팅 🔌"
  "Here is routing basics.":
    "ru" -> "Вот основы маршрутизации."
    "ja" -> "以下はルーティングの基本です。"
    "zh" -> "以下是路由基础知识。"
    "fr" -> "Voici les bases du routage."
    "ko" -> "여기는 라우팅 기본 사항입니다."
  "This section will provide you with an overview of the core features and capabilities of SSR within HappyX web framework. SSR is a powerful technique that allows you to render web pages on the server-side before sending them to the client, resulting in improved performance and SEO optimization.":
    "ru" -> "Этот раздел предоставит вам обзор основных функций и возможностей SSR в рамках веб-фреймворка HappyX. SSR - это мощная техника, которая позволяет рендерить веб-страницы на сервере перед отправкой их клиенту, что приводит к улучшению производительности и оптимизации для SEO."
    "ja" -> "このセクションでは、HappyXウェブフレームワーク内のSSRのコア機能と機能について概説します。 SSRは、ウェブページをサーバーサイドでレンダリングしてからクライアントに送信する強力なテクニックで、パフォーマンス向上とSEO最適化が実現されます。"
    "zh" -> "本节将为您提供HappyX Web框架内SSR的核心功能和能力概述。 SSR是一种强大的技术，允许您在将网页发送到客户端之前在服务器端呈现它们，从而提高性能并进行SEO优化。"
    "fr" -> "Cette section vous fournira un aperçu des fonctionnalités principales et des capacités du SSR au sein du framework web HappyX. Le SSR est une technique puissante qui vous permet de rendre les pages web côté serveur avant de les envoyer au client, ce qui améliore les performances et l'optimisation pour le référencement (SEO)."
    "ko" -> "이 섹션은 HappyX 웹 프레임워크 내의 SSR의 핵심 기능 및 능력을 개요로 제공합니다. SSR은 서버 측에서 웹 페이지를 렌더링한 후 클라이언트에게 보내는 강력한 기술로, 성능 향상 및 SEO 최적화를 통해 결과를 도출합니다."
  "HappyX server-side allows to use it from Nim, Python and NodeJS!":
    "ru" -> "Серверная часть HappyX позволяет использовать ее из Nim, Python и NodeJS!"
    "ja" -> "HappyXのサーバーサイドはNim、Python、およびNodeJSから使用できます！"
    "zh" -> "HappyX服务器端允许从Nim、Python和NodeJS使用！"
    "fr" -> "Le côté serveur de HappyX permet de l'utiliser avec Nim, Python et NodeJS !"
    "ko" -> "HappyX 서버 측에서는 Nim, Python 및 NodeJS에서 사용할 수 있습니다!"
  "Minimal example in any supported language seems like that:":
    "ru" -> "Минимальный пример на любом поддерживаемом языке выглядит так:"
    "ja" -> "サポートされている言語の最小の例は次のようになります："
    "zh" -> "任何支持的语言中的最小示例看起来像这样："
    "fr" -> "Un exemple minimal dans n'importe quel langage pris en charge ressemble à ceci :"
    "ko" -> "지원되는 어떤 언어에서든 최소한의 예제는 다음과 같습니다:"
  "LiveViews":
    "ru" -> "LiveViews"
    "ja" -> "LiveViews"
    "zh" -> "LiveViews"
    "fr" -> "LiveViews"
    "ko" -> "LiveViews"
  ".hpx files support":
    "ru" -> "поддержка файлов .hpx"
    "ja" -> ".hpx ファイルのサポート"
    "zh" -> ".hpx 文件支持"
    "fr" -> "support des fichiers .hpx"
    "ko" -> ".hpx 파일 지원"
  "NodeJS Bindings":
    "ru" -> "Привязки NodeJS"
    "ja" -> "NodeJS バインディング"
    "zh" -> "NodeJS 绑定"
    "fr" -> "Liens NodeJS"
    "ko" -> "NodeJS 바인딩"
  "Advanced 🧪":
    "ru" -> "Продвинутое 🧪"
    "ja" -> "高度な 🧪"
    "zh" -> "高级 🧪"
    "fr" -> "Avancé 🧪"
    "ko" -> "고급 🧪"
  "Tailwind And Other 🎴":
    "ru" -> "Tailwind и другие 🎴"
    "ja" -> "Tailwind およびその他 🎴"
    "zh" -> "Tailwind 和其他 🎴"
    "fr" -> "Tailwind et autres 🎴"
    "ko" -> "Tailwind 및 기타 🎴"
  "You can actually use most of the JS libraries with HappyX":
    "ru" -> "На самом деле вы можете использовать большинство библиотек JS с HappyX"
    "ja" -> "実際には、HappyXでほとんどのJSライブラリを使用できます"
    "zh" -> "实际上，您可以在HappyX中使用大多数JS库"
    "fr" -> "Vous pouvez en fait utiliser la plupart des bibliothèques JS avec HappyX"
    "ko" -> "실제로 HappyX에서 대부분의 JS 라이브러리를 사용할 수 있습니다"
  "Simple Usage 🔨":
    "ru" -> "Простое использование 🔨"
    "ja" -> "簡単な使用 🔨"
    "zh" -> "简单使用 🔨"
    "fr" -> "Utilisation simple 🔨"
    "ko" -> "간단한 사용 🔨"
  "To use JS libraries you can use cdn.":
    "ru" -> "Для использования библиотек JS вы можете использовать cdn."
    "ja" -> "JSライブラリを使用するには、cdnを使用できます。"
    "zh" -> "要使用JS库，您可以使用cdn。"
    "fr" -> "Pour utiliser des bibliothèques JS, vous pouvez utiliser cdn."
    "ko" -> "JS 라이브러리를 사용하려면 cdn을 사용할 수 있습니다."
  "SSR Nim Version can be:":
    "ru" -> "Версия SSR Nim может быть:"
    "ja" -> "SSR Nim バージョンは次のようになります："
    "zh" -> "SSR Nim 版本可以是："
    "fr" -> "La version SSR Nim peut être :"
    "ko" -> "SSR Nim 버전은 다음과 같을 수 있습니다:"
  "SPA Nim Version can be:":
    "ru" -> "Версия SPA Nim может быть:"
    "ja" -> "SPA Nim バージョンは次のようになります："
    "zh" -> "SPA Nim 版本可以是："
    "fr" -> "La version SPA Nim peut être :"
    "ko" -> "SPA Nim 버전은 다음과 같을 수 있습니다:"
  "Advanced Usage with NodeJS 🧪":
    "ru" -> "Расширенное использование с NodeJS 🧪"
    "ja" -> "NodeJSを使用した高度な使用法 🧪"
    "zh" -> "使用NodeJS进行高级使用 🧪"
    "fr" -> "Utilisation avancée avec NodeJS 🧪"
    "ko" -> "NodeJS를 사용한 고급 사용 🧪"
  "Some libraries provides CLI and other tools to working.":
    "ru" -> "Некоторые библиотеки предоставляют CLI и другие инструменты для работы."
    "ja" -> "一部のライブラリはCLIおよびその他のツールを提供しています。"
    "zh" -> "一些库提供了CLI和其他工具以供使用。"
    "fr" -> "Certaines bibliothèques fournissent une interface CLI et d'autres outils pour travailler."
    "ko" -> "일부 라이브러리는 작업에 CLI 및 기타 도구를 제공합니다."
  "Going back to Tailwind CSS - it has an observing CLI. With it, you can use Tailwind without the CLI. ":
    "ru" -> "Возвращаясь к Tailwind CSS - у него есть наблюдающий CLI. С его помощью вы можете использовать Tailwind без CLI. "
    "ja" -> "Tailwind CSSに戻ると、監視CLIがあります。これを使用すると、CLIなしでTailwindを使用できます。 "
    "zh" -> "回到Tailwind CSS - 它有一个观察CLI。通过它，您可以在没有CLI的情况下使用Tailwind。 "
    "fr" -> "Revenons à Tailwind CSS - il dispose d'une interface CLI d'observation. Avec cela, vous pouvez utiliser Tailwind sans la CLI. "
    "ko" -> "Tailwind CSS로 돌아가보면 관찰 CLI가 있습니다. 이를 사용하면 CLI없이 Tailwind를 사용할 수 있습니다. "
  "To use it let's repeat these steps:":
    "ru" -> "Чтобы использовать его, давайте повторим эти шаги:"
    "ja" -> "それを使用するために、これらのステップを繰り返しましょう："
    "zh" -> "要使用它，让我们重复以下步骤："
    "fr" -> "Pour l'utiliser, répétons ces étapes :"
    "ko" -> "사용하려면 다음 단계를 반복하겠습니다:"
  "Then, go to ":
    "ru" -> "Затем перейдите к файлу "
    "ja" -> "次に、ファイルに移動します "
    "zh" -> "然后，转到文件 "
    "fr" -> "Ensuite, accédez au fichier "
    "ko" -> "그런 다음 파일로 이동하십시오 "
  " and change it":
    "ru" -> " и измените его"
    "ja" -> " そしてそれを変更してください"
    "zh" -> " 并进行更改"
    "fr" -> " et modifiez-le"
    "ko" -> " 그리고 변경하십시오"
  "After, create ":
    "ru" -> "Затем создайте "
    "ja" -> "その後、作成します "
    "zh" -> "之后，创建 "
    "fr" -> "Ensuite, créez "
    "ko" -> "그 후 생성하십시오 "
  "And run watching command":
    "ru" -> "И выполните команду отслеживания изменений"
    "ja" -> "監視コマンドを実行してください"
    "zh" -> "运行观察命令"
    "fr" -> "Exécutez la commande d'observation"
    "ko" -> "감시 명령을 실행하십시오"
  "After all steps you can write any html/nim files with tailwind support":
    "ru" -> "После всех шагов вы можете писать любые файлы html/nim с поддержкой Tailwind"
    "ja" -> "すべての手順が完了したら、Tailwindをサポートする任意のhtml/nimファイルを書くことができます"
    "zh" -> "在所有步骤完成之后，您可以编写任何带有Tailwind支持的html/nim文件"
    "fr" -> "Après toutes les étapes, vous pouvez écrire n'importe quel fichier html/nim avec la prise en charge de Tailwind"
    "ko" -> "모든 단계를 거친 후에는 Tailwind를 지원하는 HTML/Nim 파일을 작성할 수 있습니다"
  "In any web framework you can work with status code, headers, cookies, etc. So HappyX give you it!":
    "ru" -> "В любом веб-фреймворке вы можете работать с кодом состояния, заголовками, куками и т. д. Итак, HappyX предоставляет вам это!"
    "ja" -> "どんなウェブフレームワークでも、ステータスコード、ヘッダー、クッキーなどを操作できます。したがって、HappyXが提供します！"
    "zh" -> "在任何Web框架中，您都可以处理状态代码、标头、Cookie等。因此，HappyX为您提供了这个！"
    "fr" -> "Dans n'importe quel framework web, vous pouvez travailler avec les codes d'état, les en-têtes, les cookies, etc. Donc HappyX vous le donne !"
    "ko" -> "모든 웹 프레임워크에서 상태 코드, 헤더, 쿠키 등을 다룰 수 있습니다. 그래서 HappyX가 제공합니다!"
  "Headers, Status Code And Cookies 📦":
    "ru" -> "Заголовки, коды состояния и куки 📦"
    "ja" -> "ヘッダー、ステータスコード、クッキー 📦"
    "zh" -> "标头、状态代码和Cookie 📦"
    "fr" -> "En-têtes, codes d'état et cookies 📦"
    "ko" -> "헤더, 상태 코드 및 쿠키 📦"
  "Helpful Routes 🔌":
    "ru" -> "Полезные маршруты 🔌"
    "ja" -> "役立つルート 🔌"
    "zh" -> "有用的路由 🔌"
    "fr" -> "Itinéraires utiles 🔌"
    "ko" -> "도움말 라우트 🔌"
  "HappyX has additional useful routes - setup, middleware, notfound, onException, and staticDir":
    "ru" -> "У HappyX есть дополнительные полезные маршруты - setup, middleware, notfound, onException и staticDir"
    "ja" -> "HappyXには追加の便利なルートがあります - setup、middleware、notfound、onException、およびstaticDir"
    "zh" -> "HappyX还有其他有用的路由 - setup、middleware、notfound、onException和staticDir"
    "fr" -> "HappyX dispose de routes supplémentaires utiles - setup, middleware, notfound, onException et staticDir"
    "ko" -> "HappyX에는 추가로 유용한 경로가 있습니다 - setup, middleware, notfound, onException 및 staticDir"
  "HappyX has additional helpful routes - middleware, notfound and static directories":
    "ru" -> "У HappyX есть дополнительные полезные маршруты - middleware, notfound и статические каталоги"
    "ja" -> "HappyXには追加の便利なルートがあります - ミドルウェア、notfound、および静的ディレクトリ"
    "zh" -> "HappyX具有额外的有用路由 - 中间件、notfound和静态目录"
    "fr" -> "HappyX dispose de routes supplémentaires utiles - middleware, notfound et répertoires statiques"
    "ko" -> "HappyX에는 추가적인 유용한 라우트가 있습니다 - 미들웨어, notfound 및 정적 디렉터리"
  "Route Decorators 🔌":
    "ru" -> "Декораторы маршрутов 🔌"
    "ja" -> "ルートデコレーター 🔌"
    "zh" -> "路由装饰器 🔌"
    "fr" -> "Décorateurs de routes 🔌"
    "ko" -> "라우트 데코레이터 🔌"
  "HappyX (at Nim side) provides efficient compile-time route decorators.":
    "ru" -> "HappyX (на стороне Nim) предоставляет эффективные декораторы маршрутов на этапе компиляции."
    "ja" -> "HappyX（Nim側）は効率的なコンパイル時のルートデコレータを提供しています。"
    "zh" -> "HappyX（在Nim一侧）提供了高效的编译时路由装饰器。"
    "fr" -> "HappyX (du côté Nim) propose des décorateurs de route efficaces au moment de la compilation."
    "ko" -> "HappyX (Nim 측면에서)는 효율적인 컴파일 타임 라우트 데코레이터를 제공합니다."
  "Route decorators is little 'middleware', that edits route code at compile-time":
    "ru" -> "Декораторы маршрутов - это небольшие 'посредники', которые редактируют код маршрута во время компиляции:"
    "ja" -> "ルートデコレータは、コンパイル時にルートコードを編集する小さな 'ミドルウェア' です："
    "zh" -> "路由装饰器是一种小型的 '中间件'，它在编译时编辑路由代码："
    "fr" -> "Les décorateurs de route sont un petit 'intergiciel' qui modifie le code de la route lors de la compilation :"
    "ko" -> "루트 데코레이터는 컴파일 시간에 라우트 코드를 편집하는 작은 '미들웨어'입니다:"
  "Usage 🤔":
    "ru" -> "Использование 🤔"
    "ja" -> "使用法 🤔"
    "zh" -> "用法 🤔"
    "fr" -> "Utilisation 🤔"
    "ko" -> "사용법 🤔"
  "Here you can see simple decorator usage":
    "ru" -> "Здесь вы можете увидеть простое использование декоратора:"
    "ja" -> "ここでシンプルなデコレータの使用例が見られます："
    "zh" -> "在这里，您可以看到简单的装饰器用法："
    "fr" -> "Ici, vous pouvez voir l'utilisation simple d'un décorateur :"
    "ko" -> "여기에서 간단한 데코레이터 사용 예제를 볼 수 있습니다:"
  "Custom Decorators 💡":
    "ru" -> "Пользовательские декораторы 💡"
    "ja" -> "カスタムデコレータ 💡"
    "zh" -> "自定义装饰器 💡"
    "fr" -> "Décorateurs personnalisés 💡"
    "ko" -> "사용자 정의 데코레이터 💡"
  "You can create your own decorators also:":
    "ru" -> "Вы также можете создавать свои собственные декораторы:"
    "ja" -> "独自のデコレータも作成できます："
    "zh" -> "您还可以创建自己的装饰器："
    "fr" -> "Vous pouvez également créer vos propres décorateurs :"
    "ko" -> "자체 데코레이터도 생성할 수 있습니다:"
  "You can use route decorators in SSR, SSG, and SPA project types with Nim.":
    "ru" -> "Вы можете использовать декораторы маршрутов в проектах типов SSR, SSG и SPA с использованием Nim."
    "ja" -> "SSR、SSG、およびNimを使用したSPAプロジェクトタイプでルートデコレータを使用できます。"
    "zh" -> "您可以在使用Nim的SSR、SSG和SPA项目类型中使用路由装饰器。"
    "fr" -> "Vous pouvez utiliser des décorateurs de routes dans les types de projets SSR, SSG et SPA avec Nim."
    "ko" -> "SSR, SSG 및 SPA 프로젝트 유형에서 Nim과 함께 라우트 데코레이터를 사용할 수 있습니다."
  "Reactivity ⚡":
    "ru" -> "Реактивность ⚡"
    "ja" -> "リアクティビティ ⚡"
    "zh" -> "响应性 ⚡"
    "fr" -> "Réactivité ⚡"
    "ko" -> "반응성 ⚡"
  "Reactivity in HappyX is a mechanism that allows your web application to instantly respond to data changes without explicit developer intervention. When the data used in the application changes, the interface is automatically updated to display these changes. This makes the app more responsive and user-friendly.":
    "ru" -> "Реактивность в HappyX - это механизм, который позволяет вашему веб-приложению мгновенно реагировать на изменения данных без явного вмешательства разработчика. Когда данные, используемые в приложении, меняются, интерфейс автоматически обновляется для отображения этих изменений. Это делает приложение более отзывчивым и удобным для пользователя."
    "ja" -> "HappyXのリアクティビティは、明示的な開発者の介入なしにデータの変更に即座に応答できる仕組みです。アプリケーションで使用されるデータが変更されると、インターフェースが自動的に更新されてこれらの変更が表示されます。これにより、アプリはより反応が良く、ユーザーフレンドリーになります。"
    "zh" -> "在HappyX中，响应性是一种机制，使您的Web应用程序能够在没有显式开发者干预的情况下即时响应数据变化。当应用程序中使用的数据发生变化时，界面会自动更新以显示这些变化。这使应用程序更具响应性和用户友好性。"
    "fr" -> "La réactivité dans HappyX est un mécanisme qui permet à votre application web de réagir instantanément aux changements de données sans intervention explicite du développeur. Lorsque les données utilisées dans l'application changent, l'interface est automatiquement mise à jour pour afficher ces changements. Cela rend l'application plus réactive et conviviale."
    "ko" -> "HappyX의 반응성은 데이터 변경에 명시적인 개발자 개입없이 웹 애플리케이션이 즉시 응답할 수 있는 메커니즘입니다. 애플리케이션에서 사용하는 데이터가 변경되면 인터페이스가 자동으로 업데이트되어 이러한 변경 사항을 표시합니다. 이로써 앱은 더 반응성이 있고 사용자 친화적으로 동작합니다."
  "Here is 'naked' reactivity without components:":
    "ru" -> "Вот 'голая' реактивность без компонентов:"
    "ja" -> "ここではコンポーネントのない'素の'リアクティビティがあります："
    "zh" -> "这里是没有组件的'原始'响应性："
    "fr" -> "Voici la réactivité 'à nu' sans composants :"
    "ko" -> "여기에는 컴포넌트가없는 '맨체스터' 반응성이 있습니다:"
  "And here is reactivity with components usage:":
    "ru" -> "А вот реактивность с использованием компонентов:"
    "ja" -> "ここではコンポーネントの使用によるリアクティビティがあります："
    "zh" -> "这里是使用组件的响应性："
    "fr" -> "Et voici la réactivité avec l'utilisation de composants :"
    "ko" -> "여기에는 구성 요소 사용을 통한 반응성이 있습니다:"
  "Reactivity ⚡":
    "ru" -> "Реактивность ⚡"
    "ja" -> "リアクティビティ ⚡"
    "zh" -> "响应性 ⚡"
    "fr" -> "Réactivité ⚡"
    "ko" -> "반응성 ⚡"
  "Let's open the topic of HappyX reactivity in more detail":
    "ru" -> "Давайте более подробно рассмотрим тему реактивности в HappyX"
    "ja" -> "HappyXのリアクティビティのトピックを詳しく見てみましょう"
    "zh" -> "让我们更详细地了解HappyX响应性的主题"
    "fr" -> "Ouvrons le sujet de la réactivité dans HappyX de manière plus détaillée"
    "ko" -> "HappyX의 반응성 주제를 좀 더 자세히 살펴보겠습니다"
  "Reactivity is described in more detail in the following article.":
    "ru" -> "Реактивность подробно описана в следующей статье."
    "ja" -> "リアクティビティについては、以下の記事で詳しく説明されています。"
    "zh" -> "有关详细信息，请参阅以下文章中的响应性描述。"
    "fr" -> "La réactivité est décrite plus en détail dans l'article suivant."
    "ko" -> "반응성에 대한 자세한 내용은 다음 기사에서 설명되어 있습니다."
  "To begin with, reactivity can be used both in components and outside of components.":
    "ru" -> "Прежде всего, реактивность можно использовать как в компонентах, так и вне компонентов."
    "ja" -> "まず第一に、リアクティビティはコンポーネント内およびコンポーネント外の両方で使用できます。"
    "zh" -> "首先，响应性既可以在组件中使用，也可以在组件外使用。"
    "fr" -> "Pour commencer, la réactivité peut être utilisée à la fois dans les composants et à l'extérieur des composants."
    "ko" -> "우선, 반응성은 컴포넌트 내 및 컴포넌트 외에서 모두 사용할 수 있습니다."
  "This example shows how to interact with reactive variables in the routes of the SPA application.":
    "ru" -> "В этом примере показано, как взаимодействовать с реактивными переменными в маршрутах SPA-приложения."
    "ja" -> "この例では、SPAアプリケーションのルートでリアクティブ変数とやり取りする方法が示されています。"
    "zh" -> "此示例演示了如何在SPA应用程序的路由中与响应式变量进行交互。"
    "fr" -> "Cet exemple montre comment interagir avec des variables réactives dans les routes de l'application SPA."
    "ko" -> "이 예제에서는 SPA 애플리케이션의 라우트에서 반응형 변수와 상호 작용하는 방법을 보여줍니다."
  "As you can see in the above code example, a special syntax is used to call the ":
    "ru" -> "Как вы можете видеть в приведенном выше примере кода, используется специальный синтаксис для вызова "
    "ja" -> "上記のコード例でわかるように、特殊な構文が使用されています。"
    "zh" -> "正如您在上面的代码示例中所看到的，调用函数时使用了特殊的语法。"
    "fr" -> "Comme vous pouvez le voir dans l'exemple de code ci-dessus, une syntaxe spéciale est utilisée pour appeler la fonction "
    "ko" -> "위의 코드 예제에서 볼 수 있듯이 특수한 구문이 사용되어 함수를 호출합니다. "
  " function. This is necessary to simplify access to the value of the reactive variable.":
    "ru" -> " функции. Это необходимо для упрощения доступа к значению реактивной переменной."
    "ja" -> "関数の値へのアクセスを簡略化するためにこれが必要です。"
    "zh" -> "。这是为了简化对响应式变量值的访问。"
    "fr" -> " fonction. Cela est nécessaire pour simplifier l'accès à la valeur de la variable réactive."
    "ko" -> " 함수의 값을 간단하게 접근하기 위해서는 이것이 필요합니다."
  "In the example above, the ":
    "ru" -> "В приведенном выше примере функция "
    "ja" -> "上記の例では、"
    "zh" -> "在上面的例子中，函数调用 "
    "fr" -> "Dans l'exemple ci-dessus, la fonction "
    "ko" -> "위의 예에서는 함수 "
  " function is called without special syntax, since frequently used functions are implemented in reactive variables, such as ":
    "ru" -> " вызывается без специального синтаксиса, поскольку часто используемые функции реализованы в реактивных переменных, такие как "
    "ja" -> "特殊な構文なしに呼び出されます。"
    "zh" -> "未使用特殊的语法，因为经常使用的函数已在响应式变量中实现，比如 "
    "fr" -> " est appelée sans syntaxe spéciale, car les fonctions fréquemment utilisées sont implémentées dans des variables réactives, telles que "
    "ko" -> " 특수한 구문 없이 호출됩니다. 자주 사용되는 함수는 이미 반응형 변수에 구현되어 있습니다. 예를 들어 "
  "Let's look at an example of working with sequences.":
    "ru" -> "Давайте рассмотрим пример работы с последовательностями."
    "ja" -> "シーケンスを使用した作業の例を見てみましょう。"
    "zh" -> "让我们看一个使用序列的例子。"
    "fr" -> "Jetons un coup d'œil à un exemple de travail avec des séquences."
    "ko" -> "시퀀스를 사용한 작업의 예제를 살펴보겠습니다."
  "It is also worth noting that reactive variables are created using the remember function.":
    "ru" -> "Также стоит отметить, что реактивные переменные создаются с использованием функции remember."
    "ja" -> "また、リアクティブ変数はremember関数を使用して作成されることに注意してください。"
    "zh" -> "值得注意的是，响应式变量可经由remember函数创建。"
    "fr" -> "Il est également important de noter que les variables réactives sont créées à l'aide de la fonction remember."
    "ko" -> "또한 반응형 변수는 remember 함수를 사용하여 생성됩니다."
  "The example below shows all the other examples of creating reactive variables.":
    "ru" -> "В приведенном ниже примере показаны все другие примеры создания реактивных переменных."
    "ja" -> "以下の例では、他のすべてのリアクティブ変数の作成例が示されています。"
    "zh" -> "下面的示例显示了创建响应式变量的所有其他示例。"
    "fr" -> "L'exemple ci-dessous montre tous les autres exemples de création de variables réactives."
    "ko" -> "아래 예제에서는 반응형 변수를 만드는 다른 모든 예제가 나와 있습니다."
  "Speaking of built-in frequently used functions, it is worth noting that they can be used together with ordinary values. Let's look at the following example.":
    "ru" -> "Говоря о встроенных часто используемых функциях, стоит отметить, что их можно использовать вместе с обычными значениями. Давайте рассмотрим следующий пример."
    "ja" -> "組み込みのよく使われる関数について言及すると、普通の値と一緒に使用することができることに注意する価値があります。以下の例を見てみましょう。"
    "zh" -> "说到内置的常用函数，值得注意的是它们可以与普通值一起使用。让我们看看下面的例子。"
    "fr" -> "En parlant des fonctions intégrées fréquemment utilisées, il est important de noter qu'elles peuvent être utilisées avec des valeurs ordinaires. Jetons un coup d'œil à l'exemple suivant."
    "ko" -> "내장된 자주 사용되는 함수에 대해 언급할 때 주목할 점은 이러한 함수들이 일반 값과 함께 사용될 수 있다는 것입니다. 다음 예제를 살펴보겠습니다."
  "To specify a new value for reactivity variables, you can use ":
    "ru" -> "Чтобы указать новое значение для реактивных переменных, вы можете использовать "
    "ja" -> "リアクティビティ変数の新しい値を指定するには、"
    "zh" -> "要为响应变量指定新值，可以使用 "
    "fr" -> "Pour spécifier une nouvelle valeur pour les variables réactives, vous pouvez utiliser "
    "ko" -> "반응성 변수에 대한 새로운 값을 지정하려면 "
  ". For example, you can use ":
    "ru" -> ". Например, вы можете использовать "
    "ja" -> ". たとえば、"
    "zh" -> ". 例如，您可以使用 "
    "fr" -> ". Par exemple, vous pouvez utiliser "
    "ko" -> ". 예를 들어 "
  " to replace the entire ":
    "ru" -> " чтобы заменить весь "
    "ja" -> " 全体を置き換えるには "
    "zh" -> " 一次性整个替换 "
    "fr" -> " pour remplacer l'ensemble du "
    "ko" -> " 전체를 교체하려면 "
  " in one go.":
    "ru" -> " за один раз."
    "ja" -> " 全体を一度に置き換えるためには "
    "zh" -> " 。"
    "fr" -> " en une seule fois."
    "ko" -> " 를 사용할 수 있습니다."
  "Database access 📦":
    "ru" -> "Доступ к базе данных 📦"
    "ja" -> "データベースアクセス 📦"
    "zh" -> "数据库访问 📦"
    "fr" -> "Accès à la base de données 📦"
    "ko" -> "데이터베이스 액세스 📦"
  "In the following articles, we will look at the interaction with databases on the server side.":
    "ru" -> "В следующих статьях мы рассмотрим взаимодействие с базами данных на стороне сервера."
    "ja" -> "次の記事では、サーバーサイドでのデータベースとの連携について見ていきます。"
    "zh" -> "在接下来的文章中，我们将探讨与服务器端数据库的交互。"
    "fr" -> "Dans les articles suivants, nous examinerons l'interaction avec les bases de données côté serveur."
    "ko" -> "다음 글에서는 서버 측에서 데이터베이스와의 상호 작용을 살펴볼 것입니다."
  "You can use any available database driver implemented in Nim, Python or NodeJS":
    "ru" -> "Вы можете использовать любой доступный драйвер базы данных, реализованный на Nim, Python или NodeJS."
    "ja" -> "Nim、Python、またはNodeJSで実装された利用可能なデータベースドライバを使用できます。"
    "zh" -> "您可以使用在Nim、Python或NodeJS中实现的任何可用的数据库驱动程序。"
    "fr" -> "Vous pouvez utiliser n'importe quel pilote de base de données disponible implémenté en Nim, Python ou NodeJS."
    "ko" -> "Nim, Python 또는 NodeJS에서 구현된 사용 가능한 어떤 데이터베이스 드라이버든 사용할 수 있습니다."
  "In this article, we will look at the interaction with MongoDB on the server side.":
    "ru" -> "В этой статье мы рассмотрим взаимодействие с MongoDB на стороне сервера."
    "ja" -> "この記事では、サーバーサイドでのMongoDBとの連携を見ていきます。"
    "zh" -> "在本文中，我们将探讨与服务器端MongoDB的交互。"
    "fr" -> "Dans cet article, nous examinerons l'interaction avec MongoDB côté serveur."
    "ko" -> "이 글에서는 서버 측에서 MongoDB와의 상호 작용을 살펴보겠습니다."
  "The code below demonstrates the connection to MongoDB.":
    "ru" -> "Ниже приведен код, показывающий подключение к MongoDB."
    "ja" -> "以下のコードは、MongoDBへの接続を示しています。"
    "zh" -> "下面的代码显示了连接到MongoDB的过程。"
    "fr" -> "Le code ci-dessous montre la connexion à MongoDB."
    "ko" -> "아래 코드는 MongoDB에 연결하는 것을 보여줍니다."
  "First, you need to install MongoDB and the library for working with it.":
    "ru" -> "Сначала вам нужно установить MongoDB и библиотеку для работы с ней."
    "ja" -> "まず、MongoDBとそれを操作するためのライブラリをインストールする必要があります。"
    "zh" -> "首先，您需要安装MongoDB以及用于与其交互的库。"
    "fr" -> "Tout d'abord, vous devez installer MongoDB et la bibliothèque nécessaire pour y travailler."
    "ko" -> "먼저 MongoDB 및 그와 함께 작업하는 라이브러리를 설치해야 합니다."
  "Now let's write methods for working with the pseudo-API. Let's start by creating a user:":
    "ru" -> "Теперь давайте напишем методы для работы с псевдо-API. Начнем с создания пользователя:"
    "ja" -> "では、疑似APIとの連携のためのメソッドを記述しましょう。まず、ユーザーの作成から始めましょう。"
    "zh" -> "现在让我们编写用于与伪API交互的方法。让我们从创建用户开始："
    "fr" -> "Écrivons maintenant des méthodes pour travailler avec la pseudo-API. Commençons par créer un utilisateur :"
    "ko" -> "이제 의사-API와 상호 작용하기 위한 메서드를 작성해 봅시다. 사용자 생성부터 시작해 보겠습니다:"
  "Now let's write a method to get a user by his ID:":
    "ru" -> "Теперь давайте напишем метод для получения пользователя по его идентификатору:"
    "ja" -> "では、IDによってユーザーを取得するためのメソッドを記述しましょう。"
    "zh" -> "现在让我们编写一个按用户ID获取用户的方法："
    "fr" -> "Écrivons maintenant une méthode pour obtenir un utilisateur par son ID :"
    "ko" -> "이제 사용자 ID로 사용자를 가져오는 메서드를 작성해 봅시다:"
  "Finally, let's add a method to get all users":
    "ru" -> "Наконец, давайте добавим метод для получения всех пользователей."
    "ja" -> "最後に、すべてのユーザーを取得するためのメソッドを追加しましょう。"
    "zh" -> "最后，让我们添加一个获取所有用户的方法。"
    "fr" -> "Enfin, ajoutons une méthode pour obtenir tous les utilisateurs."
    "ko" -> "마지막으로 모든 사용자를 가져오는 메서드를 추가해 봅시다."
  "Let's take a look at the full code:":
    "ru" -> "Давайте взглянем на полный код:"
    "ja" -> "完全なコードを見てみましょう："
    "zh" -> "让我们看一下完整的代码："
    "fr" -> "Jettons un coup d'œil au code complet :"
    "ko" -> "전체 코드를 살펴보겠습니다:"
  "Now you know the basics of working with MongoDB in HappyX.":
    "ru" -> "Теперь вы знаете основы работы с MongoDB в HappyX."
    "ja" -> "これで、HappyXでMongoDBを使用する基本を知っています。"
    "zh" -> "现在您已经了解了在HappyX中使用MongoDB的基础知识。"
    "fr" -> "Maintenant, vous connaissez les bases de travail avec MongoDB dans HappyX."
    "ko" -> "이제 HappyX에서 MongoDB를 사용하는 기본 사항을 알게 되었습니다."
  "anonimongo documentation":
    "ru" -> "документация по anonimongo"
    "ja" -> "anonimongoのドキュメント"
    "zh" -> "anonimongo文档"
    "fr" -> "documentation sur anonimongo"
    "ko" -> "anonimongo 문서"
  "pymongo documentation":
    "ru" -> "документация по pymongo"
    "ja" -> "pymongoのドキュメント"
    "zh" -> "pymongo文档"
    "fr" -> "documentation sur pymongo"
    "ko" -> "pymongo 문서"
  "This article discusses the interaction of HappyX and SQLite using Norm library.":
    "ru" -> "Эта статья рассматривает взаимодействие HappyX и SQLite с использованием библиотеки Norm."
    "ja" -> "この記事では、Normライブラリを使用してHappyXとSQLiteとの連携について説明します。"
    "zh" -> "本文讨论了使用Norm库在HappyX和SQLite之间进行交互的问题。"
    "fr" -> "Cet article traite de l'interaction entre HappyX et SQLite en utilisant la bibliothèque Norm."
    "ko" -> "이 글은 Norm 라이브러리를 사용하여 HappyX와 SQLite 간의 상호 작용에 대해 논의합니다."
  "This article discusses the interaction of HappyX and SQLite using the sqlalchemy library.":
    "ru" -> "Эта статья рассматривает взаимодействие HappyX и SQLite с использованием библиотеки sqlalchemy."
    "ja" -> "この記事では、sqlalchemyライブラリを使用してHappyXとSQLiteとの連携について説明します。"
    "zh" -> "本文讨论了使用sqlalchemy库在HappyX和SQLite之间进行交互的问题。"
    "fr" -> "Cet article traite de l'interaction entre HappyX et SQLite en utilisant la bibliothèque sqlalchemy."
    "ko" -> "이 글은 sqlalchemy 라이브러리를 사용하여 HappyX와 SQLite 간의 상호 작용에 대해 논의합니다."
  "First, you need to install the library to work with it":
    "ru" -> "Сначала вам нужно установить библиотеку для работы с ней."
    "ja" -> "まず、ライブラリをインストールする必要があります。"
    "zh" -> "首先，您需要安装库以便使用它。"
    "fr" -> "Tout d'abord, vous devez installer la bibliothèque pour pouvoir y travailler."
    "ko" -> "먼저 해당 라이브러리를 설치해야 합니다."
  "Norm requires ``--deepcopy:on``, so you'll have to compile your project with this flag:":
    "ru" -> "Norm требует ``--deepcopy:on``, поэтому вам придется скомпилировать свой проект с этим флагом:"
    "ja" -> "Normには ``--deepcopy:on`` が必要ですので、このフラグを使用してプロジェクトをコンパイルする必要があります:"
    "zh" -> "Norm需要 ``--deepcopy:on``，因此您必须使用此标志编译您的项目："
    "fr" -> "Norm nécessite ``--deepcopy:on``, donc vous devrez compiler votre projet avec ce drapeau :"
    "ko" -> "Norm은 ``--deepcopy:on``이 필요하므로이 플래그로 프로젝트를 컴파일해야합니다:"
  "First, let's look at an example in which Norm is imported and a model is created for a table in a database.":
    "ru" -> "Сначала давайте рассмотрим пример, в котором импортируется Norm, и создается модель для таблицы в базе данных."
    "ja" -> "まず、Normがインポートされ、データベースのテーブル用のモデルが作成される例を見てみましょう。"
    "zh" -> "首先，让我们看一个例子，其中导入了Norm，并为数据库中的表创建了模型。"
    "fr" -> "Tout d'abord, examinons un exemple dans lequel Norm est importé et un modèle est créé pour une table dans une base de données."
    "ko" -> "먼저 Norm이 가져와지고 데이터베이스의 테이블에 대한 모델이 생성되는 예제를 살펴보겠습니다."
  "The code below shows the connection to SQLite":
    "ru" -> "Ниже приведен код, показывающий подключение к SQLite."
    "ja" -> "以下のコードは、SQLiteへの接続を示しています。"
    "zh" -> "下面的代码显示了连接到SQLite的过程。"
    "fr" -> "Le code ci-dessous montre la connexion à SQLite."
    "ko" -> "아래 코드는 SQLite에 연결하는 것을 보여줍니다."
  "The code below shows connecting to SQLite and creating a model for a table in the database.":
    "ru" -> "Ниже приведен код, показывающий подключение к SQLite и создание модели для таблицы в базе данных."
    "ja" -> "以下のコードは、SQLiteへの接続とデータベースのテーブル用のモデルの作成を示しています。"
    "zh" -> "下面的代码显示了连接到SQLite并为数据库中的表创建模型。"
    "fr" -> "Le code ci-dessous montre la connexion à SQLite et la création d'un modèle pour une table dans la base de données."
    "ko" -> "아래 코드는 SQLite에 연결하고 데이터베이스의 테이블에 대한 모델을 생성하는 것을 보여줍니다."
  "Now you know the basics of working with SQLite in HappyX.":
    "ru" -> "Теперь вы знаете основы работы с SQLite в HappyX."
    "ja" -> "これで、HappyXでSQLiteを使用する基本を知っています。"
    "zh" -> "现在您已经了解了在HappyX中使用SQLite的基础知识。"
    "fr" -> "Maintenant, vous connaissez les bases de travail avec SQLite dans HappyX."
    "ko" -> "이제 HappyX에서 SQLite를 사용하는 기본 사항을 알게 되었습니다."
  "Norm documentation":
    "ru" -> "Документация по Norm"
    "ja" -> "Normのドキュメント"
    "zh" -> "Norm文档"
    "fr" -> "Documentation sur Norm"
    "ko" -> "Norm 문서"
  "sqlalchemy documentation":
    "ru" -> "Документация по sqlalchemy"
    "ja" -> "sqlalchemyのドキュメント"
    "zh" -> "sqlalchemy文档"
    "fr" -> "Documentation sur sqlalchemy"
    "ko" -> "sqlalchemy 문서"
  "Route decorators 🔌":
    "ru" -> "Декораторы маршрута 🔌"
    "ja" -> "ルートデコレータ 🔌"
    "zh" -> "路由装饰器 🔌"
    "fr" -> "Décorateurs de route 🔌"
    "ko" -> "루트 데코레이터 🔌"
  "JVM Bindings ☕":
    "ru" -> "Привязки JVM ☕"
    "ja" -> "JVMバインディング ☕"
    "zh" -> "JVM绑定 ☕"
    "fr" -> "Liens JVM ☕"
    "ko" -> "JVM 바인딩 ☕"
  "This article discusses the interaction of HappyX and PostgreSQL using Norm library.":
    "ru" -> "Эта статья рассматривает взаимодействие HappyX и PostgreSQL с использованием библиотеки Norm."
    "ja" -> "この記事では、Normライブラリを使用してHappyXとPostgreSQLの連携について説明します。"
    "zh" -> "本文讨论了使用Norm库在HappyX和PostgreSQL之间进行交互。"
    "fr" -> "Cet article traite de l'interaction entre HappyX et PostgreSQL en utilisant la bibliothèque Norm."
    "ko" -> "이 글은 Norm 라이브러리를 사용하여 HappyX와 PostgreSQL 간의 상호 작용에 대해 다룹니다."
  "This article discusses the interaction of HappyX and PostgreSQL using psycopg2 library.":
    "ru" -> "Эта статья рассматривает взаимодействие HappyX и PostgreSQL с использованием библиотеки psycopg2."
    "ja" -> "この記事では、psycopg2ライブラリを使用してHappyXとPostgreSQLの連携について説明します。"
    "zh" -> "本文讨论了使用psycopg2库在HappyX和PostgreSQL之间进行交互。"
    "fr" -> "Cet article traite de l'interaction entre HappyX et PostgreSQL en utilisant la bibliothèque psycopg2."
    "ko" -> "이 글은 psycopg2 라이브러리를 사용하여 HappyX와 PostgreSQL 간의 상호 작용에 대해 다룹니다."
  "The code below shows the connection to PostgreSQL":
    "ru" -> "Ниже приведен код, показывающий подключение к PostgreSQL."
    "ja" -> "以下のコードは、PostgreSQLへの接続を示しています。"
    "zh" -> "下面的代码显示了连接到PostgreSQL的过程。"
    "fr" -> "Le code ci-dessous montre la connexion à PostgreSQL."
    "ko" -> "아래 코드는 PostgreSQL에 연결하는 것을 보여줍니다."
  "The code below shows connecting to PostgreSQL and creating a model for a table in the database.":
    "ru" -> "Ниже приведен код, показывающий подключение к PostgreSQL и создание модели для таблицы в базе данных."
    "ja" -> "以下のコードは、PostgreSQLへの接続とデータベースのテーブル用のモデルの作成を示しています。"
    "zh" -> "下面的代码显示了连接到PostgreSQL并为数据库中的表创建模型。"
    "fr" -> "Le code ci-dessous montre la connexion à PostgreSQL et la création d'un modèle pour une table dans la base de données."
    "ko" -> "아래 코드는 PostgreSQL에 연결하고 데이터베이스의 테이블에 대한 모델을 생성하는 것을 보여줍니다."
  "Now you know the basics of working with PostgreSQL in HappyX.":
    "ru" -> "Теперь вы знаете основы работы с PostgreSQL в HappyX."
    "ja" -> "これで、HappyXでPostgreSQLを使用する基本を知っています。"
    "zh" -> "现在您已经了解了在HappyX中使用PostgreSQL的基础知识。"
    "fr" -> "Maintenant, vous connaissez les bases de travail avec PostgreSQL dans HappyX."
    "ko" -> "이제 HappyX에서 PostgreSQL을 사용하는 기본 사항을 알게 되었습니다."
  "psycopg2 documentation":
    "ru" -> "документация по psycopg2"
    "ja" -> "psycopg2のドキュメント"
    "zh" -> "psycopg2文档"
    "fr" -> "documentation sur psycopg2"
    "ko" -> "psycopg2 문서"
  "This includes all members of the HappyX community who have contributed to its development (issues and pull requests)":
    "ru" -> "Сюда входят все участники сообщества HappyX, которые внесли свой вклад в его развитие (issues и pull requests)."
    "ja" -> "これには、開発に貢献したHappyXコミュニティのすべてのメンバーが含まれています（問題やプルリクエスト）。"
    "zh" -> "这包括HappyX社区的所有成员，他们对其发展做出了贡献（问题和拉取请求）。"
    "fr" -> "Cela inclut tous les membres de la communauté HappyX qui ont contribué à son développement (problèmes et demandes de tirage)."
    "ko" -> "이에는 HappyX 커뮤니티의 모든 회원이 개발에 기여한 사람들이 포함됩니다 (이슈 및 풀 리퀘스트)."
  "Warning":
    "ru" -> "Предупреждение"
    "ja" -> "警告"
    "zh" -> "警告"
    "fr" -> "Avertissement"
    "ko" -> "경고"
  "Info":
    "ru" -> "Информация"
    "ja" -> "情報"
    "zh" -> "信息"
    "fr" -> "Info"
    "ko" -> "정보"
  " [change]":
    "ru" -> " [изменить]"
    "ja" -> " [変更]"
    "zh" -> " [更改]"
    "fr" -> " [changement]"
    "ko" -> " [변경]"
  "In addition to using typed path parameters, you can explicitly specify that they are mutable and/or optional, and you can also specify a default value":
    "ru" -> "Помимо использования типизированных параметров пути, вы можете явно указать, что они могут быть изменяемыми и/или необязательными, а также указать значение по умолчанию."
    "ja" -> "型付きのパスパラメータを使用するだけでなく、それらが変更可能および/またはオプションであることを明示的に指定し、デフォルト値も指定できます。"
    "zh" -> "除了使用类型化的路径参数，您还可以明确指定它们是可变的和/或可选的，并且还可以指定默认值。"
    "fr" -> "En plus d'utiliser des paramètres de chemin typés, vous pouvez spécifier explicitement s'ils sont mutables et/ou optionnels, et vous pouvez également spécifier une valeur par défaut."
    "ko" -> "타입화된 경로 매개변수를 사용하는 것 외에도 해당 매개변수가 변경 가능 및/또는 선택 사항임을 명시적으로 지정할 수 있으며 기본값도 지정할 수 있습니다."
  "Example":
    "ru" -> "Пример"
    "ja" -> "例"
    "zh" -> "示例"
    "fr" -> "Exemple"
    "ko" -> "예시"
  "Here is few examples:":
    "ru" -> "Вот несколько примеров:"
    "ja" -> "以下はいくつかの例です:"
    "zh" -> "以下是一些例子:"
    "fr" -> "Voici quelques exemples :"
    "ko" -> "여기 몇 가지 예시가 있습니다:"
  "Optional integer":
    "ru" -> "Необязательный целочисленный параметр"
    "ja" -> "オプションの整数"
    "zh" -> "可选整数"
    "fr" -> "Entier optionnel"
    "ko" -> "선택적 정수"
  "Optional path param typed as int with default value 0":
    "ru" -> "Необязательный параметр пути с типом int и значением по умолчанию 0"
    "ja" -> "デフォルト値0のオプションの整数型パスパラメータ"
    "zh" -> "可选路径参数，类型为int，默认值为0"
    "fr" -> "Paramètre de chemin optionnel typé en tant qu'entier avec une valeur par défaut de 0"
    "ko" -> "기본값이 0인 선택적으로 정의된 정수형 경로 매개변수"
  "default bool":
    "ru" -> "Булевой параметр с значением по умолчанию"
    "ja" -> "デフォルトブール"
    "zh" -> "默认布尔值"
    "fr" -> "Booléen par défaut"
    "ko" -> "기본값이 있는 부울 매개변수"
  "Optional path param typed as bool with default value false":
    "ru" -> "Необязательный параметр пути с типом bool и значением по умолчанию false"
    "ja" -> "デフォルト値falseのオプションのブール型パスパラメータ"
    "zh" -> "可选路径参数，类型为bool，默认值为false"
    "fr" -> "Paramètre de chemin optionnel typé en tant que booléen avec une valeur par défaut de false"
    "ko" -> "기본값이 false인 선택적으로 정의된 부울형 경로 매개변수"
  "Optional path param typed as float with default value 3.14":
    "ru" -> "Необязательный параметр пути с типом float и значением по умолчанию 3.14"
    "ja" -> "デフォルト値が3.14のfloat型オプションパスパラメーター"
    "zh" -> "类型为float且默认值为3.14的可选路径参数"
    "fr" -> "Paramètre de chemin optionnel de type float avec une valeur par défaut de 3,14"
    "ko" -> "기본값이 3.14인 float형 선택 경로 매개변수"
  "Default float":
    "ru" -> "Значение по умолчанию float"
    "ja" -> "デフォルトのfloat"
    "zh" -> "默认float"
    "fr" -> "Float par défaut"
    "ko" -> "기본 float"
  "string":
    "ru" -> "строка"
    "ja" -> "文字列"
    "zh" -> "字符串"
    "fr" -> "chaîne"
    "ko" -> "문자열"
  "Path param typed as string":
    "ru" -> "Параметр пути с типом string"
    "ja" -> "文字列型のパスパラメータ"
    "zh" -> "类型为字符串的路径参数"
    "fr" -> "Paramètre de chemin de type chaîne de caractères"
    "ko" -> "문자열로 유형 지정된 경로 매개변수"
  "not available":
    "ru" -> "недоступно"
    "ja" -> "利用不可"
    "zh" -> "不可用"
    "fr" -> "non disponible"
    "ko" -> "사용 불가"
  "▶ Sandbox":
    "ru" -> "▶ Песочница"
    "ja" -> "▶ サンドボックス"
    "zh" -> "▶ 沙盒"
    "fr" -> "▶ Bac à sable"
    "ko" -> "▶ 샌드박스"
  "🌏 Language":
    "ru" -> "🌏 Язык"
    "ja" -> "🌏 言語"
    "zh" -> "🌏 语言"
    "fr" -> "🌏 Langue"
    "ko" -> "🌏 언어"
  "Components 🔥":
    "ru" -> "Компоненты 🔥"
    "ja" -> "コンポーネント 🔥"
    "zh" -> "组件 🔥"
    "fr" -> "Composants 🔥"
    "ko" -> "컴포넌트 🔥"
  "This article describes components and their behavior":
    "ru" -> "Эта статья описывает компоненты и их поведение"
    "ja" -> "この記事では、コンポーネントとその動作について説明します"
    "zh" -> "本文描述了组件及其行为"
    "fr" -> "Cet article décrit les composants et leur comportement"
    "ko" -> "이 글은 컴포넌트와 그들의 동작에 대해 설명합니다"
  "Button Example":
    "ru" -> "Пример кнопки"
    "ja" -> "ボタンの例"
    "zh" -> "按钮示例"
    "fr" -> "Exemple de bouton"
    "ko" -> "버튼 예제"
  "Let's look at Button component example":
    "ru" -> "Давайте рассмотрим пример компонента кнопки"
    "ja" -> "ボタンコンポーネントの例を見てみましょう"
    "zh" -> "让我们看看按钮组件的例子"
    "fr" -> "Voyons un exemple de composant bouton"
    "ko" -> "버튼 컴포넌트 예제를 살펴보겠습니다"
  "Click":
    "ru" -> "Нажатие"
    "ja" -> "クリック"
    "zh" -> "点击"
    "fr" -> "Cliquez"
    "ko" -> "클릭"
  "Firstly, user clicks on the button":
    "ru" -> "Сначала пользователь нажимает на кнопку"
    "ja" -> "最初にユーザーがボタンをクリックします"
    "zh" -> "首先，用户点击按钮"
    "fr" -> "Tout d'abord, l'utilisateur clique sur le bouton"
    "ko" -> "먼저 사용자가 버튼을 클릭합니다"
  "Clicked":
    "ru" -> "Нажатие"
    "ja" -> "クリック"
    "zh" -> "点击"
    "fr" -> "Cliqué"
    "ko" -> "클릭됨"
  "@click event was detected":
    "ru" -> "Обнаружено событие @click"
    "ja" -> "@click イベントが検出されました"
    "zh" -> "检测到 @click 事件"
    "fr" -> "L'événement @click a été détecté"
    "ko" -> "@click 이벤트가 감지되었습니다"
  "Counter up":
    "ru" -> "Увеличение счетчика"
    "ja" -> "カウンターが1増えます"
    "zh" -> "计数器增加1"
    "fr" -> "Augmentation du compteur"
    "ko" -> "버튼 값 (self.counter)이 1만큼 증가"
  "buttons'value (self.counter) increases by 1":
    "ru" -> "Значение кнопки (self.counter) увеличивается на 1"
    "ja" -> "ボタンの値 (self.counter) が1増加"
    "zh" -> "按钮值 (self.counter) 增加1"
    "fr" -> "La valeur du bouton (self.counter) augmente de 1"
    "ko" -> "버튼 값 (self.counter)이 1만큼 증가"
  "Re-rendering":
    "ru" -> "Повторный рендеринг"
    "ja" -> "再レンダリング"
    "zh" -> "重新渲染"
    "fr" -> "Rendu à nouveau"
    "ko" -> "재렌더링"
  "Current component detects that state was changed and re-renders only current component":
    "ru" -> "Текущий компонент обнаруживает, что состояние изменилось, и перерисовывает только текущий компонент"
    "ja" -> "現在のコンポーネントは、状態が変更されたことを検出し、現在のコンポーネントのみを再レンダリングします"
    "zh" -> "当前组件检测到状态已更改，并仅重新渲染当前组件"
    "fr" -> "Le composant actuel détecte que l'état a changé et le rendu se refait uniquement sur le composant actuel"
    "ko" -> "현재 컴포넌트는 상태가 변경되었음을 감지하고 현재 컴포넌트만 다시 렌더링합니다"
  "HappyX Sandbox ▶":
    "ru" -> "Песочница HappyX ▶"
    "ja" -> "HappyX サンドボックス ▶"
    "zh" -> "HappyX 沙盒 ▶"
    "fr" -> "HappyX Bac à sable ▶"
    "ko" -> "HappyX 샌드박스 ▶"
  "Generics 👶":
    "ru" -> "Дженерики 👶"
    "ja" -> "ジェネリクス 👶"
    "zh" -> "泛型 👶"
    "fr" -> "Génériques 👶"
    "ko" -> "일반화 👶"
  "More flexibility 🔥":
    "ru" -> "Больше гибкости 🔥"
    "ja" -> "より柔軟性を持たせる 🔥"
    "zh" -> "更多灵活性 🔥"
    "fr" -> "Plus de flexibilité 🔥"
    "ko" -> "더 많은 유연성 🔥"
  "Future":
    "ru" -> "Будущее"
    "ja" -> "将来"
    "zh" -> "未来"
    "fr" -> "Futur"
    "ko" -> "미래"
  "Metaprogramming 🔨":
    "ru" -> "Метапрограммирование 🔨"
    "ja" -> "メタプログラミング 🔨"
    "zh" -> "元编程 🔨"
    "fr" -> "Méta-programmation 🔨"
    "ko" -> "메타프로그래밍 🔨"
  "Improve Python bindings 🔥":
    "ru" -> "Улучшить привязки Python 🔥"
    "ja" -> "Pythonのバインディングを改善する 🔥"
    "zh" -> "改进Python绑定 🔥"
    "fr" -> "Améliorer les liaisons Python 🔥"
    "ko" -> "Python 바인딩 개선하기 🔥"
  "The example above illustrates how HappyX handles clicks, and also demonstrates interaction with reactive data of the component.":
    "ru" -> "Приведенный выше пример иллюстрирует, как HappyX обрабатывает клики, а также демонстрирует взаимодействие с реактивными данными компонента."
    "ja" -> "上記の例は、HappyXがクリックを処理する方法を示しており、コンポーネントの反応データとの相互作用も示しています。"
    "zh" -> "上面的例子说明了HappyX如何处理点击，并展示了与组件的响应数据的交互。"
    "fr" -> "L'exemple ci-dessus illustre comment HappyX gère les clics et démontre également l'interaction avec les données réactives du composant."
    "ko" -> "위의 예시는 HappyX가 클릭을 처리하는 방법을 보여주며, 또한 구성 요소의 반응 데이터와 상호 작용을 나타냅니다."
  "In this section, we will talk about using Swagger and Redoc in HappyX.":
    "ru" -> "В этой секции мы поговорим об использовании Swagger и Redoc в HappyX."
    "ja" -> "このセクションでは、HappyXでSwaggerとRedocを使用する方法について説明します。"
    "zh" -> "在本节中，我们将讨论在HappyX中使用Swagger和Redoc的方法。"
    "fr" -> "Dans cette section, nous parlerons de l'utilisation de Swagger et Redoc dans HappyX."
    "ko" -> "이 섹션에서는 HappyX에서 Swagger 및 Redoc 사용에 대해 이야기하겠습니다."
  "Swagger and Redoc in HappyX 📕":
    "ru" -> "Swagger и Redoc в HappyX 📕"
    "ja" -> "SwaggerとRedocはHappyXで 📕"
    "zh" -> "Swagger和Redoc在HappyX中 📕"
    "fr" -> "Swagger et Redoc dans HappyX 📕"
    "ko" -> "HappyX에서의 Swagger 및 Redoc 📕"
  "Let's start by creating a basic route that will return Hello, world! We'll document it right away.":
    "ru" -> "Давайте начнем с создания базового маршрута, который будет возвращать Привет, мир! Мы сразу его задокументируем."
    "ja" -> "まず、Hello、world!を返す基本的なルートを作成しましょう。すぐにドキュメント化します。"
    "zh" -> "让我们首先创建一个基本路由，它将返回Hello, world! 我们将立即对其进行文档化。"
    "fr" -> "Commençons par créer une route de base qui renverra Bonjour, le monde! Nous le documenterons tout de suite."
    "ko" -> "우리는 바로 Hello, world!를 반환할 기본 경로를 만들어 보겠습니다. 바로 문서화하겠습니다."
  "Now that we've documented it, let's go ahead and run it and check the following address:":
    "ru" -> "Теперь, когда мы его задокументировали, давайте запустим и проверим следующий адрес:"
    "ja" -> "これを文書化したので、さあ実行して、次のアドレスを確認しましょう："
    "zh" -> "既然我们已经对其进行了文档化，那么让我们运行它并检查以下地址："
    "fr" -> "Maintenant que nous l'avons documenté, allons-y et exécutons-le et vérifions l'adresse suivante :"
    "ko" -> "이제 문서화했으니 실행하고 다음 주소를 확인해 봅시다:"
  "Here we can see our route and the description we provided for it. You can also view the Swagger documentation at the following address:":
    "ru" -> "Здесь мы видим наш маршрут и описание, которое мы ему предоставили. Вы также можете просмотреть документацию Swagger по следующему адресу:"
    "ja" -> "ここでは、ルートとその説明を見ることができます。また、次のアドレスでSwaggerドキュメントを表示することもできます："
    "zh" -> "在这里，我们可以看到我们的路由和我们为其提供的描述。您还可以查看以下地址的Swagger文档："
    "fr" -> "Ici, nous pouvons voir notre route et la description que nous avons fournie pour celle-ci. Vous pouvez également consulter la documentation Swagger à l'adresse suivante :"
    "ko" -> "여기서 우리의 경로와 우리가 제공 한 설명을 볼 수 있습니다. 또한 다음 주소에서 Swagger 문서를 볼 수도 있습니다:"
  "In addition, for Swagger, you can write in Markdown:":
    "ru" -> "Кроме того, для Swagger вы можете писать на Markdown:"
    "ja" -> "さらに、SwaggerではMarkdownで書くことができます："
    "zh" -> "此外，对于Swagger，您可以使用Markdown编写："
    "fr" -> "De plus, pour Swagger, vous pouvez écrire en Markdown :"
    "ko" -> "또한 Swagger에서는 Markdown으로 작성할 수 있습니다:"
  "Functional components ✨":
    "ru" -> "Функциональные компоненты ✨"
    "ja" -> "機能コンポーネント ✨"
    "zh" -> "功能组件 ✨"
    "fr" -> "Composants fonctionnels ✨"
    "ko" -> "기능 컴포넌트 ✨"
  "Generics for request models 🔥":
    "ru" -> "Дженерики для моделей запроса 🔥"
    "ja" -> "リクエストモデルのためのジェネリック 🔥"
    "zh" -> "请求模型的泛型 🔥"
    "fr" -> "Génériques pour les modèles de requête 🔥"
    "ko" -> "요청 모델을위한 제네릭 🔥"
  "New rendering system 🧪":
    "ru" -> "Новая система отрисовки 🧪"
    "ja" -> "新しいレンダリングシステム 🧪"
    "zh" -> "新的渲染系统 🧪"
    "fr" -> "Nouveau système de rendu 🧪"
    "ko" -> "새로운 렌더링 시스템 🧪"
  "Components can have an unlimited number of props. These props can have default values.":
    "ru" -> "Компоненты могут иметь неограниченное количество свойств. Эти свойства могут иметь значения по умолчанию."
    "ja" -> "コンポーネントには無制限のプロパティを持たせることができます。これらのプロパティにはデフォルト値を持たせることができます。"
    "zh" -> "组件可以拥有无限数量的属性。这些属性可以有默认值。"
    "fr" -> "Les composants peuvent avoir un nombre illimité de props. Ces props peuvent avoir des valeurs par défaut."
    "ko" -> "컴포넌트는 무제한의 속성을 가질 수 있습니다. 이러한 속성은 기본값을 가질 수 있습니다."
  "Component properties":
    "ru" -> "Свойства компонентов"
    "ja" -> "コンポーネントのプロパティ"
    "zh" -> "组件属性"
    "fr" -> "Propriétés des composants"
    "ko" -> "컴포넌트 속성"
  "It is worth remembering that each property is automatically wrapped in State[].":
    "ru" -> "Стоит помнить, что каждое свойство автоматически оборачивается в State[]."
    "ja" -> "各プロパティは自動的にState[]でラップされることを覚えておく価値があります。"
    "zh" -> "值得记住的是，每个属性都会自动包装在State[]中。"
    "fr" -> "Il est bon de se rappeler que chaque propriété est automatiquement enveloppée dans State[]."
    "ko" -> "각 속성은 자동으로 State[]으로 래핑되는 것을 기억하는 것이 좋습니다."
  "Component styles":
    "ru" -> "Стили компонента"
    "ja" -> "コンポーネントのスタイル"
    "zh" -> "组件样式"
    "fr" -> "Styles des composants"
    "ko" -> "컴포넌트 스타일"
  "Each component can have its own styles. They are isolated for each instance of the component.":
    "ru" -> "Каждый компонент может иметь свои стили. Они изолированы для каждого экземпляра компонента."
    "ja" -> "各コンポーネントには独自のスタイルがあります。それらはコンポーネントの各インスタンスに対して分離されています。"
    "zh" -> "每个组件都可以有自己的样式。它们针对组件的每个实例进行了隔离。"
    "fr" -> "Chaque composant peut avoir ses propres styles. Ils sont isolés pour chaque instance du composant."
    "ko" -> "각 컴포넌트는 자체 스타일을 가질 수 있습니다. 이 스타일은 컴포넌트의 각 인스턴스에 대해 격리됩니다."
  "In this case, styles are applied only to the buttons inside the component. You may also notice that component property values can be inserted into styles.":
    "ru" -> "В данном случае стили применяются только для кнопок внутри компонента. Вы также можете заметить, что в стили можно вставлять значения свойств компонента."
    "ja" -> "この場合、スタイルはコンポーネント内のボタンにのみ適用されます。また、コンポーネントのプロパティ値をスタイルに挿入することができることに気付くかもしれません。"
    "zh" -> "在这种情况下，样式仅适用于组件内的按钮。您还可以注意到可以将组件属性值插入到样式中。"
    "fr" -> "Dans ce cas, les styles sont appliqués uniquement aux boutons à l'intérieur du composant. Vous remarquerez également que les valeurs des propriétés du composant peuvent être insérées dans les styles."
    "ko" -> "이 경우에는 스타일이 컴포넌트 내의 버튼에만 적용됩니다. 또한 컴포넌트 속성 값이 스타일에 삽입될 수 있다는 것을 알 수 있습니다."
  "Component scripts":
    "ru" -> "Скрипты компонентов"
    "ja" -> "コンポーネントスクリプト"
    "zh" -> "组件脚本"
    "fr" -> "Scripts des composants"
    "ko" -> "컴포넌트 스크립트"
  "Each component can have its own script. This part of the code is executed directly before the component is rendered. Keep that in mind.":
    "ru" -> "Каждый компонент может иметь собственный скрипт. Эта часть кода выполняется непосредственно перед тем, как компонент будет отрисован. Имейте это ввиду."
    "ja" -> "各コンポーネントには独自のスクリプトがあります。このコードの部分は、コンポーネントがレンダリングされる直前に直接実行されます。それを覚えておいてください。"
    "zh" -> "每个组件都可以有自己的脚本。这部分代码在组件被渲染之前直接执行。请记住这一点。"
    "fr" -> "Chaque composant peut avoir son propre script. Cette partie du code est exécutée juste avant que le composant ne soit rendu. Gardez cela à l'esprit."
    "ko" -> "각 컴포넌트는 자체 스크립트를 가질 수 있습니다. 이 코드 부분은 컴포넌트가 렌더링되기 직전에 직접 실행됩니다. 이를 염두에 두십시오."
  "Component hooks":
    "ru" -> "Хуки компонента"
    "ja" -> "コンポーネントフック"
    "zh" -> "组件钩子"
    "fr" -> "Hooks des composants"
    "ko" -> "컴포넌트 훅"
  "Components have a variety of different events. These include":
    "ru" -> "Компоненты имеют ряд различных событий. Сюда включаются"
    "ja" -> "コンポーネントにはさまざまな種類のイベントがあります。これには"
    "zh" -> "组件有各种不同的事件。这些包括"
    "fr" -> "Les composants ont une variété d'événements différents. Cela comprend"
    "ko" -> "컴포넌트에는 다양한 다른 이벤트가 있습니다. 이러한 이벤트에는"
  "Called once when the component is created.":
    "ru" -> "Вызывается один раз при создании компонента."
    "ja" -> "コンポーネントが作成されたときに1回呼び出されます。"
    "zh" -> "在组件创建时调用一次。"
    "fr" -> "Appelé une fois lorsque le composant est créé."
    "ko" -> "컴포넌트가 생성될 때 한 번 호출됩니다."
  "Called when the HTML is fully updated.":
    "ru" -> "Вызывается при полном обновлении HTML."
    "ja" -> "HTMLが完全に更新されたときに呼び出されます。"
    "zh" -> "当HTML完全更新时调用。"
    "fr" -> "Appelé lorsque le HTML est entièrement mis à jour."
    "ko" -> "HTML이 완전히 업데이트 될 때 호출됩니다."
  "Called immediately after the component is rendered (before HTML update).":
    "ru" -> "Вызывается сразу после отрисовки компонента (до обновления HTML)."
    "ja" -> "コンポーネントがレンダリングされた直後に呼び出されます（HTMLの更新前）。"
    "zh" -> "在组件呈现后立即调用（HTML更新之前）。"
    "fr" -> "Appelé immédiatement après le rendu du composant (avant la mise à jour HTML)."
    "ko" -> "컴포넌트가 렌더링된 직후에 호출됩니다(HTML 업데이트 전)."
  "Called before the component is rendered.":
    "ru" -> "Вызывается до отрисовки компонента."
    "ja" -> "コンポーネントがレンダリングされる前に呼び出されます。"
    "zh" -> "在组件渲染之前调用。"
    "fr" -> "Appelé avant que le composant ne soit rendu."
    "ko" -> "컴포넌트가 렌더링되기 전에 호출됩니다."
  "Called during the window.beforeunload event.":
    "ru" -> "Вызывается во время события window.beforeunload."
    "ja" -> "window.beforeunloadイベント中に呼び出されます。"
    "zh" -> "在window.beforeunload事件期间调用。"
    "fr" -> "Appelé pendant l'événement window.beforeunload."
    "ko" -> "window.beforeunload 이벤트 중에 호출됩니다."
  "Called during the window.pagehide event.":
    "ru" -> "Вызывается во время события window.pagehide."
    "ja" -> "window.pagehideイベント中に呼び出されます。"
    "zh" -> "在window.pagehide事件期间调用。"
    "fr" -> "Appelé pendant l'événement window.pagehide."
    "ko" -> "window.pagehide 이벤트 중에 호출됩니다."
  "Called during the window.pageshow event.":
    "ru" -> "Вызывается во время события window.pageshow."
    "ja" -> "window.pageshowイベント中に呼び出されます。"
    "zh" -> "在window.pageshow事件期间调用。"
    "fr" -> "Appelé pendant l'événement window.pageshow."
    "ko" -> "window.pageshow 이벤트 중에 호출됩니다."
  "Here's how it all works together:":
    "ru" -> "Вот, как все это работает вместе:"
    "ja" -> "これがすべてが一緒に動作する方法です："
    "zh" -> "以下是它们如何一起工作的："
    "fr" -> "Voici comment tout cela fonctionne ensemble :"
    "ko" -> "모두가 함께 동작하는 방법은 다음과 같습니다:"
  "Functional components 🧪":
    "ru" -> "Функциональные компоненты 🧪"
    "ja" -> "機能コンポーネント 🧪"
    "zh" -> "功能组件 🧪"
    "fr" -> "Composants fonctionnels 🧪"
    "ko" -> "기능 컴포넌트 🧪"
  "This part explains functional components and how they work.":
    "ru" -> "В этой части объясняются функциональные компоненты и как они работают."
    "ja" -> "この部分では、機能コンポーネントとその動作について説明します。"
    "zh" -> "本部分将解释功能组件及其工作原理。"
    "fr" -> "Cette partie explique les composants fonctionnels et leur fonctionnement."
    "ko" -> "이 부분에서는 기능 컴포넌트 및 작동 방식에 대해 설명합니다."
  "Difference from regular components":
    "ru" -> "Отличие от обычных компонентов"
    "ja" -> "通常のコンポーネントとの違い"
    "zh" -> "与常规组件的区别"
    "fr" -> "Différence par rapport aux composants classiques"
    "ko" -> "일반적인 컴포넌트와의 차이"
  "Unlike regular components, functional components do not support inheritance, properties, methods, and other features of regular components.":
    "ru" -> "В отличие от обычных компонентов функциональные компоненты не поддерживают наследование, свойства, методы и другие возможности обычных компонентов."
    "ja" -> "通常のコンポーネントとは異なり、機能コンポーネントは継承、プロパティ、メソッド、およびその他の通常のコンポーネントの機能をサポートしません。"
    "zh" -> "与常规组件不同，函数组件不支持常规组件的继承、属性、方法和其他功能。"
    "fr" -> "Contrairement aux composants classiques, les composants fonctionnels ne prennent pas en charge l'héritage, les propriétés, les méthodes et autres fonctionnalités des composants classiques."
    "ko" -> "일반적인 컴포넌트와는 달리 함수형 컴포넌트는 상속, 속성, 메서드 및 기타 일반적인 컴포넌트의 기능을 지원하지 않습니다."
  "Based on their name, functional components are functions that return VDOM.":
    "ru" -> "Исходя из названия - функциональные компоненты представляют собой функции, которые возвращают VDOM."
    "ja" -> "その名前からもわかるように、機能コンポーネントはVDOMを返す関数です。"
    "zh" -> "根据其名称，函数组件是返回VDOM的函数。"
    "fr" -> "Selon leur nom, les composants fonctionnels sont des fonctions qui renvoient du VDOM."
    "ko" -> "그 이름에서도 알 수 있듯이 함수형 컴포넌트는 VDOM을 반환하는 함수입니다."
  "Here's an example of a simple functional component:":
    "ru" -> "Вот пример простого функционального компонента:"
    "ja" -> "以下はシンプルな機能コンポーネントの例です："
    "zh" -> "以下是一个简单的函数组件的示例："
    "fr" -> "Voici un exemple de composant fonctionnel simple :"
    "ko" -> "간단한 함수형 컴포넌트의 예제입니다:"
  "As you can see, functional components always return the TagRef type. This is the VDOM.":
    "ru" -> "Как можно заметить, функциональные компоненты обязательно возвращают тип TagRef. Это и есть VDOM."
    "ja" -> "ご覧の通り、機能コンポーネントは常にTagRef型を返します。これがVDOMです。"
    "zh" -> "正如您所见，函数组件始终返回TagRef类型。这就是VDOM。"
    "fr" -> "Comme vous pouvez le constater, les composants fonctionnels retournent toujours le type TagRef. C'est le VDOM."
    "ko" -> "함수형 컴포넌트는 항상 TagRef 유형을 반환합니다. 이것이 VDOM입니다."
  "You are free to handle the outgoing VDOM as you wish, not necessarily adhering to the template above.":
    "ru" -> "Вы вольны обрабатывать выходящий VDOM как хотите, не обязательно придерживаться шаблона выше."
    "ja" -> "出力されるVDOMを自由に扱うことができます。上記のテンプレートに従う必要はありません。"
    "zh" -> "您可以根据自己的意愿处理输出的VDOM，不一定要遵循上面的模板。"
    "fr" -> "Vous êtes libre de manipuler le VDOM sortant comme vous le souhaitez, sans nécessairement suivre le modèle ci-dessus."
    "ko" -> "원하는 대로 출력되는 VDOM을 처리할 수 있으며, 위의 템플릿을 따를 필요는 없습니다."
  "In addition, functional components, like regular ones, support slots. To use a slot, you need to define the last argument of the function like this:":
    "ru" -> "Помимо этого, функциональные компоненты, как и обычные, поддерживают слоты. Для использования слота необходимо задавать последний аргумент функции так:"
    "ja" -> "さらに、通常のコンポーネントと同様に、機能コンポーネントもスロットをサポートしています。スロットを使用するには、関数の最後の引数を次のように定義する必要があります："
    "zh" -> "此外，与常规组件一样，函数组件也支持插槽。要使用插槽，您需要将函数的最后一个参数定义为如下形式："
    "fr" -> "De plus, les composants fonctionnels, tout comme les composants réguliers, prennent en charge les slots. Pour utiliser un slot, vous devez définir le dernier argument de la fonction comme ceci :"
    "ko" -> "또한, 일반적인 것과 마찬가지로 함수형 컴포넌트는 슬롯을 지원합니다. 슬롯을 사용하려면 함수의 마지막 인수를 다음과 같이 정의해야 합니다:"
  "It is important that the argument is named exactly like this and nothing else! Default value can be omitted.":
    "ru" -> "Важно, чтобы аргумент был назван именно так и никак иначе! Значение по умолчанию можно не указывать."
    "ja" -> "この引数の名前が厳密にこれと同じであることが重要です！デフォルト値は省略できます。"
    "zh" -> "重要的是参数的命名必须完全一样，不能有其他变化！默认值可以省略。"
    "fr" -> "Il est important que l'argument soit nommé exactement comme cela et rien d'autre ! La valeur par défaut peut être omise."
    "ko" -> "이 인수의 이름이 정확히 이와 같아야 하며 다른 이름으로 지정해서는 안 됩니다! 기본값은 생략할 수 있습니다."
  "Here's an example of a component using a slot:":
    "ru" -> "Вот пример компонента с использованием слота:"
    "ja" -> "スロットを使用したコンポーネントの例は次の通りです："
    "zh" -> "以下是使用插槽的组件示例："
    "fr" -> "Voici un exemple de composant utilisant un slot :"
    "ko" -> "슬롯을 사용하는 컴포넌트의 예제는 다음과 같습니다:"
  "Slots in functional components":
    "ru" -> "Слоты функциональных компонентов"
    "ja" -> "機能コンポーネントのスロット"
    "zh" -> "函数组件中的插槽"
    "fr" -> "Slots dans les composants fonctionnels"
    "ko" -> "함수형 컴포넌트의 슬롯"
  "About slots in components":
    "ru" -> "О слотах в компонентах"
    "ja" -> "コンポーネントのスロットについて"
    "zh" -> "关于组件中的插槽"
    "fr" -> "À propos des slots dans les composants"
    "ko" -> "컴포넌트의 슬롯에 대하여"
  "You can pass HTML into the component at any time. This is quite simple to do. You need to add a special instruction inside the HTML -":
    "ru" -> "Вы можете в любой момент передать HTML внутрь компонента. Сделать это довольно просто. Нужно добавить внутрь HTML специальную инструкцию -"
    "ja" -> "コンポーネントにいつでもHTMLを渡すことができます。これは非常に簡単です。HTML内に特別な命令を追加する必要があります -"
    "zh" -> "您可以随时将HTML传递到组件中。这相当简单。您需要在HTML中添加一个特殊指令 -"
    "fr" -> "Vous pouvez passer du HTML dans le composant à tout moment. C'est assez simple à faire. Vous devez ajouter une instruction spéciale dans le HTML -"
    "ko" -> "언제든지 컴포넌트에 HTML을 전달할 수 있습니다. 이는 매우 간단합니다. HTML 내부에 특별 지시문을 추가해야 합니다 -"
  "It looks like this:":
    "ru" -> "Выглядит это следующим образом:"
    "ja" -> "このようになります："
    "zh" -> "它看起来像这样："
    "fr" -> "Ça ressemble à ceci :"
    "ko" -> "다음과 같이 보입니다:"
  "It's quite simple to use them. It looks like this:":
    "ru" -> "Использовать их довольно просто. Выглядит это так:"
    "ja" -> "使用するのは非常に簡単です。このようになります："
    "zh" -> "使用它们非常简单。看起来像这样："
    "fr" -> "Les utiliser est assez simple. Ça ressemble à ceci :"
    "ko" -> "사용하는 것은 매우 간단합니다. 다음과 같이 보입니다:"
  "From this example, we can see that only HTML text is passed into the button slot. However, we can pass HTML of any complexity into the slot.":
    "ru" -> "Из этого примера мы можем увидеть, что в слот кнопки передается лишь HTML текст. Однако мы можем передавать HTML любой сложности внутрь слота."
    "ja" -> "この例から、ボタンスロットにはHTMLテキストのみが渡されることがわかります。しかし、スロット内に任意の複雑なHTMLを渡すことができます。"
    "zh" -> "从这个例子中，我们可以看到只有HTML文本被传递到按钮插槽。然而，我们可以将任何复杂的HTML传递到插槽中。"
    "fr" -> "D'après cet exemple, nous pouvons voir que seul du texte HTML est passé dans le slot du bouton. Cependant, nous pouvons passer du HTML de n'importe quelle complexité dans le slot."
    "ko" -> "이 예제에서 우리는 버튼 슬롯에 HTML 텍스트만 전달되는 것을 볼 수 있습니다. 그러나 슬롯에 복잡한 HTML을 전달할 수 있습니다."
  "At the same time, using slots in functional components is almost no different from regular components. Here's how you can use the component we declared above:":
    "ru" -> "При этом использование слотов в функциональных компонентах практически ничем не отличается от обычных. Вот как можно использовать компонент, который мы объявили выше:"
    "ja" -> "同時に、機能コンポーネントでのスロットの使用は通常のコンポーネントとほとんど違いはありません。以下は、上記で宣言したコンポーネントの使用方法です："
    "zh" -> "同时，在函数组件中使用插槽与常规组件几乎没有什么不同。以下是如何使用我们上面声明的组件："
    "fr" -> "En même temps, l'utilisation des slots dans les composants fonctionnels est presque identique à celle des composants classiques. Voici comment utiliser le composant que nous avons déclaré ci-dessus :"
    "ko" -> "동시에 함수형 컴포넌트에서 슬롯을 사용하는 것은 일반 컴포넌트와 거의 다르지 않습니다. 우리가 위에서 선언한 컴포넌트를 사용하는 방법은 다음과 같습니다:"
  "SPA Rendering 🧩":
    "ru" -> "SPA Rendering 🧩"
    "ja" -> "SPAレンダリング 🧩"
    "zh" -> "SPA渲染 🧩"
    "fr" -> "Rendu SPA 🧩"
    "ko" -> "SPA 렌더링 🧩"
  "This part of the documentation shows the rendering logic of single-page applications in HappyX":
    "ru" -> "В этой части документации отображена логика отрисовки одностраничных приложений в HappyX"
    "ja" -> "このドキュメントのこの部分では、HappyXでのシングルページアプリケーションのレンダリングロジックを示しています"
    "zh" -> "本文档的这一部分显示了HappyX中单页应用程序的渲染逻辑"
    "fr" -> "Cette partie de la documentation montre la logique de rendu des applications à page unique dans HappyX"
    "ko" -> "이 문서의 이 부분에서는 HappyX에서 단일 페이지 애플리케이션의 렌더링 로직을 보여줍니다"
  "Application rendering order":
    "ru" -> "Порядок отрисовки приложения"
    "ja" -> "アプリケーションのレンダリング順序"
    "zh" -> "应用程序渲染顺序"
    "fr" -> "Ordre de rendu de l'application"
    "ko" -> "애플리케이션 렌더링 순서"
  "On the first visit to the site, after the JavaScript event":
    "ru" -> "При первом заходе на сайт, после JavaScript события"
    "ja" -> "サイトに初めてアクセスした際、JavaScriptイベントの後"
    "zh" -> "首次访问网站时，在JavaScript事件之后"
    "fr" -> "Lors de la première visite sur le site, après l'événement JavaScript"
    "ko" -> "사이트를 처음 방문할 때, JavaScript 이벤트 후"
  "a full rendering of the entire current page occurs.":
    "ru" -> "происходит полная отрисовка всей текущей страницы."
    "ja" -> "現在のページ全体が完全にレンダリングされます。"
    "zh" -> "当前整个页面将完全渲染。"
    "fr" -> "un rendu complet de la page actuelle se produit."
    "ko" -> "현재 페이지 전체가 완전히 렌더링됩니다."
  "Further rendering occurs after comparing the virtual DOM with the real DOM.":
    "ru" -> "Далее отрисовка происходит после сравнения виртуального DOM с реальным DOM."
    "ja" -> "その後のレンダリングは、仮想DOMと実際のDOMを比較した後に行われます。"
    "zh" -> "之后的渲染在比较虚拟DOM与实际DOM后发生。"
    "fr" -> "Le rendu ultérieur se produit après avoir comparé le DOM virtuel avec le DOM réel."
    "ko" -> "이후 렌더링은 가상 DOM과 실제 DOM을 비교한 후에 발생합니다."
  "If there is any deviation of the next new virtual DOM from the real one, the real DOM is changed.":
    "ru" -> "При любом отклонении очередного нового виртуального DOM от реального происходит изменение реального DOM."
    "ja" -> "次の新しい仮想DOMが実際のDOMと異なる場合、実際のDOMが変更されます。"
    "zh" -> "如果新的虚拟DOM与实际DOM有任何偏差，则更改实际DOM。"
    "fr" -> "Si le nouveau DOM virtuel présente une quelconque déviation par rapport au DOM réel, le DOM réel est modifié."
    "ko" -> "새로운 가상 DOM이 실제 DOM과 다를 경우 실제 DOM이 변경됩니다."
  "Such an algorithm is useful for frequent and precise changes on sites with a large amount of content.":
    "ru" -> "Такой алгоритм полезен при частых и точечных изменениях на сайтах с большим количеством контента."
    "ja" -> "このようなアルゴリズムは、コンテンツが多いサイトでの頻繁かつ正確な変更に役立ちます。"
    "zh" -> "这种算法对于内容丰富的网站上的频繁和精确更改非常有用。"
    "fr" -> "Un tel algorithme est utile pour des changements fréquents et précis sur des sites avec un grand nombre de contenus."
    "ko" -> "이러한 알고리즘은 많은 콘텐츠가 있는 사이트에서 빈번하고 정확한 변경에 유용합니다."
  "For clarity, let's look at the example below:":
    "ru" -> "Для наглядности можем рассмотреть пример ниже:"
    "ja" -> "わかりやすいように、以下の例を見てみましょう："
    "zh" -> "为便于说明，让我们看看下面的例子："
    "fr" -> "Pour plus de clarté, examinons l'exemple ci-dessous :"
    "ko" -> "명확하게 하기 위해 아래 예제를 살펴보겠습니다:"
  "In the example above, on the first visit to the site, a variable is first declared":
    "ru" -> "В примере выше, при первом заходе на сайт сначала объявляется переменная"
    "ja" -> "上記の例では、サイトに初めてアクセスした際に最初に変数が宣言されます"
    "zh" -> "在上面的例子中，首次访问该网站时，首先声明了一个变量"
    "fr" -> "Dans l'exemple ci-dessus, lors de la première visite sur le site, une variable est d'abord déclarée"
    "ko" -> "위의 예제에서 사이트에 처음 방문할 때 먼저 변수가 선언됩니다"
  " then the initial rendering of the entire virtual DOM occurs (based on the page you are on).":
    "ru" -> ", затем происходит первичная отрисовка всего виртуального DOM (исходя из страницы, на которой вы находитесь)."
    "ja" -> " その後、仮想DOM全体の初期レンダリングが行われます（あなたがいるページに基づいて）。"
    "zh" -> " 然后发生整个虚拟DOM的初始渲染（基于您所在的页面）。"
    "fr" -> " puis le rendu initial de l'ensemble du DOM virtuel se produit (en fonction de la page sur laquelle vous vous trouvez)."
    "ko" -> " 그런 다음 전체 가상 DOM의 초기 렌더링이 발생합니다 (당신이 있는 페이지를 기반으로)."
  "Example":
    "ru" -> "Пример"
    "ja" -> "例"
    "zh" -> "例子"
    "fr" -> "Exemple"
    "ko" -> "예시"
  "Custom path parameters are currently deprecated and not used.":
    "ru" -> "Кастомные параметры пути на данный момент устарели и не используются."
    "ja" -> "カスタムパスパラメーターは現在非推奨で使用されていません。"
    "zh" -> "自定义路径参数目前已被弃用，不再使用。"
    "fr" -> "Les paramètres de chemin personnalisés sont actuellement obsolètes et ne sont pas utilisés."
    "ko" -> "맞춤 경로 매개변수는 현재 사용되지 않으며 사용되지 않습니다."
  "Third-party routes 💫":
    "ru" -> "Сторонние маршруты 💫"
    "ja" -> "サードパーティのルート 💫"
    "zh" -> "第三方路由 💫"
    "fr" -> "Routes tierces 💫"
    "ko" -> "타사 경로 💫"
  "Server applications typically have a large number of routes.":
    "ru" -> "Обычно серверные приложения имеют большое количество маршрутов."
    "ja" -> "通常、サーバーアプリケーションには多数のルートがあります。"
    "zh" -> "服务器应用程序通常有大量的路由。"
    "fr" -> "Les applications serveur ont généralement un grand nombre de routes."
    "ko" -> "서버 애플리케이션에는 일반적으로 많은 경로가 있습니다."
  "For convenience, it is customary to separate them.":
    "ru" -> "Для удобства их принято разделять."
    "ja" -> "便利のために、それらを分けるのが一般的です。"
    "zh" -> "为了方便，通常会将它们分开。"
    "fr" -> "Par commodité, il est d'usage de les séparer."
    "ko" -> "편의를 위해 이들을 분리하는 것이 일반적입니다."
  "In HappyX, this is done using mounting.":
    "ru" -> "В HappyX это делается с помощью монтирования."
    "ja" -> "HappyXでは、これがマウントを使用して行われます。"
    "zh" -> "在HappyX中，这是通过挂载来完成的。"
    "fr" -> "Dans HappyX, cela se fait en utilisant le montage."
    "ko" -> "HappyX에서는 이 작업을 마운팅을 사용하여 수행합니다."
  "Let's take a look at the example below:":
    "ru" -> "Давайте взглянем на пример ниже:"
    "ja" -> "以下の例を見てみましょう："
    "zh" -> "让我们看看下面的例子："
    "fr" -> "Jetons un coup d'œil à l'exemple ci-dessous :"
    "ko" -> "아래 예제를 살펴보겠습니다:"
  "Here we define additional routes that start with":
    "ru" -> "Здесь мы задаем дополнительные маршруты, которые начинаются с"
    "ja" -> "ここで、追加のルートを定義します。そのルートは以下から始まります"
    "zh" -> "在这里，我们定义了以...开头的附加路由"
    "fr" -> "Ici, nous définissons des routes supplémentaires qui commencent par"
    "ko" -> "여기에서 시작하는 추가 경로를 정의합니다"
  "It is important to note that such mounted routes can easily be moved to separate files and modules for greater convenience.":
    "ru" -> "Важно отметить, что такие монтированные маршруты спокойно можно вынести в отдельные файлы и модули для большего удобства."
    "ja" -> "このようなマウントされたルートは、より便利にするために別々のファイルやモジュールに簡単に移動できることに注意することが重要です。"
    "zh" -> "重要的是要注意，这种挂载的路由可以轻松移动到单独的文件和模块中，以提高便利性。"
    "fr" -> "Il est important de noter que de telles routes montées peuvent facilement être déplacées vers des fichiers et des modules séparés pour plus de commodité."
    "ko" -> "이러한 마운트된 경로는 더 큰 편의를 위해 별도의 파일 및 모듈로 쉽게 이동할 수 있다는 점을 유의해야 합니다."
  "A little sugar":
    "ru" -> "Немного сахара"
    "ja" -> "ちょっとした糖分"
    "zh" -> "一点糖分"
    "fr" -> "Un peu de sucre"
    "ko" -> "약간의 설탕"
  "Using Nim, you can also use syntactic sugar that allows you to define separate routes without resorting to mounting:":
    "ru" -> "Используя Nim вы можете также использовать синтаксический сахар, который позволяет выносить отдельные маршруты не прибегая к монтированию:"
    "ja" -> "Nimを使用すると、マウントに頼らずに別々のルートを定義できる構文シュガーも使用できます："
    "zh" -> "使用Nim，您还可以使用语法糖，无需挂载即可定义单独的路由："
    "fr" -> "En utilisant Nim, vous pouvez également utiliser du sucre syntaxique qui vous permet de définir des routes séparées sans avoir recours au montage :"
    "ko" -> "Nim을 사용하면 마운팅을 사용하지 않고 별도의 경로를 정의할 수 있는 문법적 설탕도 사용할 수 있습니다:"
  "HappyX for ...":
    "ru" -> "HappyX для ..."
    "ja" -> "HappyXのための..."
    "zh" -> "HappyX的..."
    "fr" -> "HappyX pour ..."
    "ko" -> "...를 위한 HappyX"
  "Karax users 👑":
    "ru" -> "пользователей Karax 👑"
    "ja" -> "Karaxユーザー 👑"
    "zh" -> "Karax用户 👑"
    "fr" -> "utilisateurs de Karax 👑"
    "ko" -> "Karax 사용자 👑"
  "HappyX for Karax users 👑":
    "ru" -> "HappyX для пользователей Karax 👑"
    "ja" -> "KaraxユーザーのためのHappyX 👑"
    "zh" -> "Karax用户的HappyX 👑"
    "fr" -> "HappyX pour les utilisateurs de Karax 👑"
    "ko" -> "Karax 사용자를 위한 HappyX 👑"
  "This article discusses the differences between Karax and HappyX, as well as their pros and cons.":
    "ru" -> "В этой статье рассматривается разница между Karax и HappyX, а также их плюсы и минусы."
    "ja" -> "この記事では、KaraxとHappyXの違い、およびそれぞれの長所と短所について説明します。"
    "zh" -> "本文讨论了Karax和HappyX之间的差异，以及它们的优缺点。"
    "fr" -> "Cet article aborde les différences entre Karax et HappyX, ainsi que leurs avantages et inconvénients."
    "ko" -> "이 기사에서는 Karax와 HappyX의 차이점과 장단점에 대해 설명합니다."
  "I propose to consider the first example from the Karax README:":
    "ru" -> "Предлагаю рассмотреть первый пример из README Karax:"
    "ja" -> "Karax READMEの最初の例を検討しましょう："
    "zh" -> "我建议考虑Karax README中的第一个示例："
    "fr" -> "Je propose d'examiner le premier exemple du README de Karax :"
    "ko" -> "Karax README의 첫 번째 예제를 살펴보겠습니다:"
  "Here's how you can rewrite it using HappyX:":
    "ru" -> "Вот, как это можно переписать, используя HappyX:"
    "ja" -> "これをHappyXを使用して書き直す方法は次のとおりです："
    "zh" -> "以下是使用HappyX重写它的方法："
    "fr" -> "Voici comment le réécrire en utilisant HappyX :"
    "ko" -> "다음은 HappyX를 사용하여 이를 다시 작성하는 방법입니다:"
  "However, if you look again, you can see that the Karax example uses a function that returns VDOM.":
    "ru" -> "Однако, если взглянуть еще раз - можно увидеть, что в примере с Karax используется функция, которая возвращает VDOM."
    "ja" -> "しかし、もう一度見ると、Karaxの例ではVDOMを返す関数が使用されていることがわかります。"
    "zh" -> "然而，如果再看一遍，你会发现Karax示例使用了一个返回VDOM的函数。"
    "fr" -> "Cependant, si vous regardez à nouveau, vous pouvez voir que l'exemple de Karax utilise une fonction qui renvoie un VDOM."
    "ko" -> "그러나 다시 보면 Karax 예제에서는 VDOM을 반환하는 함수를 사용하고 있음을 알 수 있습니다."
  "In HappyX, you can also use functions to generate VDOM:":
    "ru" -> "В HappyX также можно использовать функции для генерации VDOM:"
    "ja" -> "HappyXでは、VDOMを生成するために関数を使用することもできます："
    "zh" -> "在HappyX中，你也可以使用函数来生成VDOM："
    "fr" -> "Dans HappyX, vous pouvez également utiliser des fonctions pour générer un VDOM :"
    "ko" -> "HappyX에서는 VDOM을 생성하기 위해 함수도 사용할 수 있습니다:"
  "The event model":
    "ru" -> "Модель событий"
    "ja" -> "イベントモデル"
    "zh" -> "事件模型"
    "fr" -> "Le modèle d'événement"
    "ko" -> "이벤트 모델"
  "Now let's consider the event model provided by HappyX and Karax.":
    "ru" -> "Теперь рассмотрим модель событий, которую предоставляют HappyX и Karax."
    "ja" -> "さて、HappyXとKaraxが提供するイベントモデルについて考えてみましょう。"
    "zh" -> "现在让我们来看看HappyX和Karax提供的事件模型。"
    "fr" -> "Maintenant, examinons le modèle d'événement proposé par HappyX et Karax."
    "ko" -> "이제 HappyX와 Karax가 제공하는 이벤트 모델을 살펴보겠습니다."
  "Unlike Karax, HappyX does not change the event model and allows you to embed as many events as you like on a single element.":
    "ru" -> "В отличие от Karax, HappyX не изменяет модель событий и позволяет вам встраивать сколько угодно событий на один элемент."
    "ja" -> "Karaxとは異なり、HappyXはイベントモデルを変更せず、1つの要素に複数のイベントを埋め込むことができます。"
    "zh" -> "与Karax不同，HappyX不会改变事件模型，并允许您在单个元素上嵌入任意多的事件。"
    "fr" -> "Contrairement à Karax, HappyX ne modifie pas le modèle d'événement et vous permet d'intégrer autant d'événements que vous le souhaitez sur un seul élément."
    "ko" -> "Karax와는 달리 HappyX는 이벤트 모델을 변경하지 않으며 하나의 요소에 여러 이벤트를 임베드할 수 있습니다."
  "You are also free to change the variable name responsible for the event:":
    "ru" -> "Вы также вольны изменять название переменной, отвечающей за событие:"
    "ja" -> "イベントに責任を持つ変数名を自由に変更することもできます："
    "zh" -> "您还可以自由更改负责事件的变量名称："
    "fr" -> "Vous êtes également libre de changer le nom de la variable responsable de l'événement :"
    "ko" -> "이벤트를 처리하는 변수 이름을 자유롭게 변경할 수도 있습니다:"
  "Regular expressions have been removed from routing 🔌":
    "ru" -> "Регулярные выражения были убраны из роутинга 🔌"
    "ja" -> "正規表現はルーティングから削除されました 🔌"
    "zh" -> "正则表达式已从路由中删除 🔌"
    "fr" -> "Les expressions régulières ont été supprimées du routage 🔌"
    "ko" -> "정규 표현식이 라우팅에서 제거되었습니다 🔌"
  "The Karax README also describes the reactivity model. Let's compare them:":
    "ru" -> "В README Karax описана также модель реактивности. Сравним и их:"
    "ja" -> "Karax READMEにはリアクティビティモデルについても記載されています。これらを比較してみましょう："
    "zh" -> "Karax README中还描述了反应性模型。让我们比较一下它们："
    "fr" -> "Le README de Karax décrit également le modèle de réactivité. Comparons-les :"
    "ko" -> "Karax README에는 반응성 모델도 설명되어 있습니다. 비교해 봅시다:"
  "As you can see, the reactivity model in HappyX is more simplified compared to Karax.":
    "ru" -> "Как вы видите - модель реактивности в HappyX более упрощена, нежели в Karax."
    "ja" -> "ご覧のとおり、HappyXのリアクティビティモデルはKaraxと比較してより簡素化されています。"
    "zh" -> "如您所见，HappyX中的反应性模型比Karax更加简化。"
    "fr" -> "Comme vous pouvez le voir, le modèle de réactivité dans HappyX est plus simplifié par rapport à Karax."
    "ko" -> "보시다시피 HappyX의 반응성 모델은 Karax에 비해 더 단순화되어 있습니다."
  "You are free to specify which variables should be reactive and which should be ordinary.":
    "ru" -> "Вы сами вольны указывать, какие переменные должны быть реактивными, а какие обычными."
    "ja" -> "どの変数をリアクティブにし、どの変数を通常のものにするかを自由に指定できます。"
    "zh" -> "您可以自由指定哪些变量应该是反应性的，哪些应该是普通的。"
    "fr" -> "Vous êtes libre de spécifier quelles variables doivent être réactives et lesquelles doivent être ordinaires."
    "ko" -> "어떤 변수가 반응적이어야 하고 어떤 변수가 일반적이어야 하는지 자유롭게 지정할 수 있습니다."
  "Besides single-page and server-side applications, you can also develop so-called liveviews.":
    "ru" -> "Помимо одностраничных и серверных приложений вы также можете разрабатывать так называемые liveviews."
    "ja" -> "シングルページアプリケーションやサーバーサイドアプリケーションの他に、いわゆるライブビューも開発できます。"
    "zh" -> "除了单页和服务器端应用程序，您还可以开发所谓的实时视图。"
    "fr" -> "Outre les applications monopages et côté serveur, vous pouvez également développer ce que l'on appelle des liveviews."
    "ko" -> "단일 페이지 및 서버 측 애플리케이션 외에도 소위 라이브 뷰를 개발할 수 있습니다."
  "Liveviews allow you to develop hybrid web applications where data processing and storage occur on the server side, while rendering happens on the client side.":
    "ru" -> "liveviews позволяют вам разрабатывать гибридные веб приложения, обработка и хранение данных которых происходит на серверной части, а отрисовка на клиентской."
    "ja" -> "ライブビューを使用すると、データの処理と保存がサーバー側で行われ、レンダリングがクライアント側で行われるハイブリッドWebアプリケーションを開発できます。"
    "zh" -> "实时视图允许您开发混合web应用程序，其中数据处理和存储发生在服务器端，而渲染发生在客户端。"
    "fr" -> "Les liveviews vous permettent de développer des applications web hybrides où le traitement et le stockage des données se font côté serveur, tandis que le rendu se fait côté client."
    "ko" -> "라이브뷰를 통해 데이터 처리 및 저장은 서버 측에서, 렌더링은 클라이언트 측에서 이루어지는 하이브리드 웹 애플리케이션을 개발할 수 있습니다."
  "Below is a diagram showing the behavior of a typical hybrid application written in HappyX.":
    "ru" -> "Ниже приведена диаграмма, отображающая поведение типичного гибридного приложения, написанного на HappyX."
    "ja" -> "以下は、HappyXで作成された典型的なハイブリッドアプリケーションの動作を示す図です。"
    "zh" -> "下面是一个图表，显示了用HappyX编写的典型混合应用程序的行为。"
    "fr" -> "Voici un diagramme montrant le comportement d'une application hybride typique écrite en HappyX."
    "ko" -> "아래는 HappyX로 작성된 일반적인 하이브리드 애플리케이션의 동작을 보여주는 다이어그램입니다."
  "Please note that liveviews are provided to developers as an experiment.":
    "ru" -> "Прошу обратить внимание на то, что liveviews предоставляется разработчикам как эксперимент."
    "ja" -> "ライブビューは実験として開発者に提供されていることに注意してください。"
    "zh" -> "请注意，实时视图是作为实验提供给开发人员的。"
    "fr" -> "Veuillez noter que les liveviews sont fournies aux développeurs à titre expérimental."
    "ko" -> "라이브뷰는 실험적으로 개발자에게 제공된다는 점에 유의하십시오."
  "In the future, the development of liveviews is likely to be modified.":
    "ru" -> "В будущем скорее всего разработка liveviews будет видоизменена."
    "ja" -> "将来的には、ライブビューの開発が変更される可能性があります。"
    "zh" -> "未来，实时视图的开发很可能会被修改。"
    "fr" -> "À l'avenir, le développement des liveviews sera probablement modifié."
    "ko" -> "미래에는 라이브뷰 개발이 수정될 가능성이 큽니다."
  "Counter App":
    "ru" -> "Counter App"
    "ja" -> "カウンターアプリ"
    "zh" -> "计数器应用"
    "fr" -> "Application de compteur"
    "ko" -> "카운터 앱"
  "Let's look at an example of a hybrid application using a counter as an example.":
    "ru" -> "Давайте рассмотрим пример гибридного приложения на примере счетчика."
    "ja" -> "カウンターを例にとって、ハイブリッドアプリケーションの例を見てみましょう。"
    "zh" -> "让我们通过一个计数器的例子来看一个混合应用程序的例子。"
    "fr" -> "Regardons un exemple d'application hybride en utilisant un compteur comme exemple."
    "ko" -> "카운터를 예로 하여 하이브리드 애플리케이션의 예를 살펴보겠습니다."
  "It is important to note that liveviews allow you to use the reactivity of single-page applications.":
    "ru" -> "Важно отметить, что liveviews позволяют пользоваться реактивностью одностраничных приложений."
    "ja" -> "ライブビューを使用すると、シングルページアプリケーションのリアクティビティを利用できることに注意してください。"
    "zh" -> "重要的是要注意，实时视图允许您使用单页应用程序的反应性。"
    "fr" -> "Il est important de noter que les liveviews vous permettent d'utiliser la réactivité des applications monopages."
    "ko" -> "라이브뷰는 단일 페이지 애플리케이션의 반응성을 사용할 수 있도록 해준다는 점을 유의하십시오."


var spokenLang: cstring
try:
  buildJs:
    ~spokenLang = localStorage["happyx_spoken_language"]
except:
  spokenLang = ""
if spokenLang.len != 0:
  languageSettings.set($spokenLang)

var languages* = @[
  ("English", "en"),
  ("Русский", "ru"),
  ("Français", "fr"),
  ("日本語", "ja"),
  ("中文", "zh"),
  ("한국어", "ko"),
]

proc langTitles*: seq[string] =
  result = @[]
  for i in languages:
    result.add(i[0])
proc langCodes*: seq[string] =
  result = @[]
  for i in languages:
    result.add(i[1])
